

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Other instructions &mdash; Write An LLVM Backend Tutorial For Cpu0</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Write An LLVM Backend Tutorial For Cpu0" href="index.html" />
    <link rel="next" title="Generate obj file" href="genobj.html" />
    <link rel="prev" title="LLVM Backend Structure" href="backendstructure.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="genobj.html" title="Generate obj file"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="backendstructure.html" title="LLVM Backend Structure"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Write An LLVM Backend Tutorial For Cpu0</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="other-instructions">
<h1>Other instructions<a class="headerlink" href="#other-instructions" title="Permalink to this headline">¶</a></h1>
<p>This chapter add more cpu0 arithmetic instructions support first.
The logic operation <strong>“not”</strong> support and translation in
<a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#operator-not">section Operator “not” !</a>. The <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#display-llvm-ir-nodes-with-graphviz">section Display llvm IR nodes with Graphviz</a>
will show you the DAG optimization steps and their corresponding llc display
options.
These DAG optimization steps result can be displayed by the graphic tool of
Graphviz which supply very useful information with graphic view.
You will appreciate Graphviz support in debug, we think.
In <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#adjust-cpu0-instructions">section Adjust cpu0 instructions</a>,
we adjust cpu0 instructions to support some data type for C language.
The <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#local-variable-pointer">section Local variable pointer</a> introduce you the local variable pointer
translation.
Finally, <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#operator-mod">section Operator mod, %</a> take care the C operator %.</p>
<div class="section" id="support-arithmetic-instructions">
<h2>Support arithmetic instructions<a class="headerlink" href="#support-arithmetic-instructions" title="Permalink to this headline">¶</a></h2>
<p>Run the 3/5/Cpu0 llc with input file ch4_1_1.bc will get the error as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch4_1_1.cpp</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Gamma@localhost 3<span class="o">]</span><span class="nv">$ </span>clang -c ch4_1_1.cpp -emit-llvm -o ch4_1_1.bc
<span class="o">[</span>Gamma@localhost 3<span class="o">]</span><span class="nv">$ </span>llvm-dis ch4_1_1.bc -o ch4_1_1.ll
<span class="o">[</span>Gamma@localhost 3<span class="o">]</span><span class="nv">$ </span>cat ch4_1.ll
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch4_1_1.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:</span>
<span class="s2">64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-</span>
<span class="s2">n8:16:32:64-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;x86_64-unknown-linux-gnu&quot;</span>

define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
  %1 <span class="o">=</span> alloca i32, align 4
  %a <span class="o">=</span> alloca i32, align 4
  %b <span class="o">=</span> alloca i32, align 4
  %c <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %1
  store i32 5, i32* %a, align 4
  store i32 2, i32* %b, align 4
  store i32 0, i32* %c, align 4
  %2 <span class="o">=</span> load i32* %a, align 4
  %3 <span class="o">=</span> load i32* %b, align 4
  %4 <span class="o">=</span> add nsw i32 %2, %3
  store i32 %4, i32* %c, align 4
  %5 <span class="o">=</span> load i32* %c, align 4
  ret i32 %5
<span class="o">}</span>
<span class="o">[</span>Gamma@localhost 3<span class="o">]</span><span class="nv">$ </span>/usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/bin/
llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch4_1_1.bc -o ch4_1_1.
cpu0.s
LLVM ERROR: Cannot <span class="k">select</span>: 0x30da480: <span class="nv">i32</span> <span class="o">=</span> add 0x30da280, 0x30da380
<span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>17<span class="o">]</span>
  0x30da280: i32,ch <span class="o">=</span> load 0x30da180, 0x30d9b80, 0x30d9880&lt;LD4<span class="o">[</span>%a<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>
  <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>15<span class="o">]</span>
        0x30d9b80: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>
        0x30d9880: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>3<span class="o">]</span>
  0x30da380: i32,ch <span class="o">=</span> load 0x30da180, 0x30d9e80, 0x30d9880&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>
  <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>14<span class="o">]</span>
        0x30d9e80: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;2&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>
        0x30d9880: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>3<span class="o">]</span>
</pre></div>
</div>
<p>This error says we have not instructions to translate IR DAG node <strong>add</strong>.
The ADDiu instruction is defined for node <strong>add</strong> with operands of 1 register
and 1 immediate.
This node <strong>add</strong> is for 2 registers.
So, appending the following code to Cpu0InstrInfo.td and Cpu0Schedule.td in
4/1/Cpu0,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0InstrInfo.td</span>
<span class="c1">/// Arithmetic Instructions (3-Operand, R-Type)</span>
<span class="n">def</span> <span class="n">CMP</span>    <span class="o">:</span> <span class="n">CmpInstr</span><span class="o">&lt;</span><span class="mh">0x10</span><span class="p">,</span> <span class="s">&quot;cmp&quot;</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">ADD</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x13</span><span class="p">,</span> <span class="s">&quot;add&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SUB</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x14</span><span class="p">,</span> <span class="s">&quot;sub&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">MUL</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x15</span><span class="p">,</span> <span class="s">&quot;mul&quot;</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">IIImul</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">DIV</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x16</span><span class="p">,</span> <span class="s">&quot;div&quot;</span><span class="p">,</span> <span class="n">sdiv</span><span class="p">,</span> <span class="n">IIIdiv</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">AND</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x18</span><span class="p">,</span> <span class="s">&quot;and&quot;</span><span class="p">,</span> <span class="n">and</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">OR</span>      <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x19</span><span class="p">,</span> <span class="s">&quot;or&quot;</span><span class="p">,</span> <span class="n">or</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">XOR</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x1A</span><span class="p">,</span> <span class="s">&quot;xor&quot;</span><span class="p">,</span> <span class="n">xor</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">/// Shift Instructions</span>
<span class="n">def</span> <span class="n">ROL</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x1C</span><span class="p">,</span> <span class="s">&quot;rol&quot;</span><span class="p">,</span> <span class="n">rotl</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">ROR</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x1D</span><span class="p">,</span> <span class="s">&quot;ror&quot;</span><span class="p">,</span> <span class="n">rotr</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SHL</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x1E</span><span class="p">,</span> <span class="s">&quot;shl&quot;</span><span class="p">,</span> <span class="n">shl</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SHR</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x1F</span><span class="p">,</span> <span class="s">&quot;shr&quot;</span><span class="p">,</span> <span class="n">sra</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Cpu0Schedule.td</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">ALU</span>     <span class="o">:</span> <span class="n">FuncUnit</span><span class="p">;</span>
<span class="n">def</span> <span class="n">IMULDIV</span> <span class="o">:</span> <span class="n">FuncUnit</span><span class="p">;</span>

<span class="c1">//===------------------------------------------------------------------===//</span>
<span class="c1">// Instruction Itinerary classes used for Cpu0</span>
<span class="c1">//===------------------------------------------------------------------===//</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">IIImul</span>             <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="n">def</span> <span class="n">IIIdiv</span>             <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>

<span class="n">def</span> <span class="n">IIPseudo</span>           <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>

<span class="c1">//===------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 Generic instruction itineraries.</span>
<span class="c1">//===------------------------------------------------------------------===//</span>
<span class="c1">// http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html</span>
<span class="n">def</span> <span class="n">Cpu0GenericItineraries</span> <span class="o">:</span> <span class="n">ProcessorItineraries</span><span class="o">&lt;</span><span class="p">[</span><span class="n">ALU</span><span class="p">,</span> <span class="n">IMULDIV</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span>
<span class="p">...</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIImul</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">17</span><span class="p">,</span> <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIIdiv</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">38</span><span class="p">,</span> <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>In RISC CPU like Mips, the multiply/divide function unit and add/sub/logic unit
are designed from two different hardware circuits, and more, their data path is
separate. We think the cpu0 is the same even though no explanation in it&#8217;s web
site.
So, these two function units can be executed at same time (instruction level
parallelism). Reference <a class="footnote-reference" href="#id6" id="id1">[1]</a> for instruction itineraries.</p>
<p>Now, let&#8217;s build 4/1/Cpu0 and run with input file ch4_1_2.cpp.
This version can process <strong>+, -, *, /, &amp;, |, ^, &lt;&lt;,</strong> and <strong>&gt;&gt;</strong> operators in C
language.
The corresponding llvm IR instructions are <strong>add, sub, mul, sdiv, and, or, xor,
shl, ashr</strong>.
IR instruction <strong>sdiv</strong> stand for signed div while <strong>udiv</strong> is for unsigned div.
The <strong>&#8216;ashr&#8217;</strong> instruction (arithmetic shift right) returns the first operand
shifted to the right a specified number of bits with sign extension.
In brief, we call <strong>ashr</strong> is “shift with sign extension fill”.</p>
<div class="code highlight-c++"><div class="highlight"><pre><span class="nl">Example:</span>
  <span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ashr</span> <span class="n">i32</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span>   <span class="p">;</span> <span class="n">yields</span> <span class="p">{</span><span class="n">i32</span><span class="p">}</span><span class="o">:</span><span class="n">result</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ashr</span> <span class="n">i8</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span>   <span class="p">;</span> <span class="n">yields</span> <span class="p">{</span><span class="n">i8</span><span class="p">}</span><span class="o">:</span><span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ashr</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span>  <span class="p">;</span> <span class="n">undefined</span>
</pre></div>
</div>
<p>The C operator <strong>&gt;&gt;</strong> for negative operand is dependent on implementation.
Most compiler translate it into “shift with sign extension fill”, for example,
Mips <strong>sra</strong> is the instruction.
Following is the Micosoft web site explanation,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>&gt;&gt;</strong>, Microsoft Specific</p>
<p class="last">The result of a right shift of a signed negative quantity is implementation
dependent.
Although Microsoft C++ propagates the most-significant bit to fill vacated
bit positions, there is no guarantee that other implementations will do
likewise.</p>
</div>
<p>In addition to <strong>ashr</strong>, the other instruction “shift with zero filled”
<strong>lshr</strong> in llvm (Mips implement lshr with instruction <strong>srl</strong>) has the
following meaning.</p>
<div class="code highlight-c++"><div class="highlight"><pre><span class="nl">Example:</span>
<span class="o">&lt;</span><span class="n">result</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">lshr</span> <span class="n">i8</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span>   <span class="p">;</span> <span class="n">yields</span> <span class="p">{</span><span class="n">i8</span><span class="p">}</span><span class="o">:</span><span class="n">result</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
</pre></div>
</div>
<p>In llvm, IR node <strong>sra</strong> is defined for ashr IR instruction, node <strong>srl</strong> is
defined for lshr instruction (I don&#8217;t know why don&#8217;t use ashr and lshr as the
IR node name directly).
We assume Cpu0 shr instruction is “shift with zero filled”, and define it with
IR DAG node srl.
But at that way, Cpu0 will fail to compile x &gt;&gt; 1 in case of x is signed
integer because clang and most compilers translate it into ashr, which meaning
“shift with sign extension fill”.
Similarly, Cpu0 div instruction, has the same problem. We assume Cpu0 div
instruction is for sdiv which can take care both positive and negative integer,
but it will fail for divide operation “/ “on unsigned integer operand in C.</p>
<p>If we consider the x &gt;&gt; 1 definition is x = x/2.
In case of x is unsigned int, range x is 0 ~ 4G-1 (0 ~ 0xFFFFFFFF) in 32 bits
register, implement shift &gt;&gt; 1 by “shift with zero filled” is correct and
satisfy the definition x = x/2, but “shift with sign extension fill” is not
correct for range 2G ~ 4G-1.
In case of x is signed int, range x is -2G ~ 2G-1, implement x &gt;&gt; 1 by “shift
with sign extension fill” is correct for the definition,
but “shift with zero filled” is not correct for range x is -2G ~ -1.
So, if x = x/2 is definition for x &gt;&gt; 1, in order to satisfy the definition in
both unsigned and signed integer of x, we need those two instructions,
“shift with zero filled” and “shift with sign extension fill”.</p>
<p>Again, consider the x &lt;&lt; 1 definition is x = x*2.
We apply the x &lt;&lt; 1 with “shift 1 bit to left and fill the least bit with 0”.
In case of x is unsigned int, x &lt;&lt; 1 satisfy the definition in range 0 ~ 2G-1,
and x is overflow when x &gt; 2G-1 (no need to care what the register value is
because overflow). In case of x is signed int, x &lt;&lt; 1 is correct for -1G ~
1G-1; and x is overflow for -2G ~ -1G-1 or 1G ~ 2G-1.
So, implementation by “shift 1bit to left and fill the least bit with 0”
satisfy the definition x = x*2 for x &lt;&lt; 1, no matter operand x is signed or
unsigned int.</p>
<p>Micorsoft implementation references as <a class="footnote-reference" href="#id7" id="id2">[2]</a>.</p>
<p>The sub-section &#8220;‘ashr‘ Instruction&#8221; and sub-section &#8220;‘lshr‘ Instruction&#8221; of
<a class="footnote-reference" href="#id8" id="id3">[3]</a>.</p>
<p>The 4/1 version just add 40 lines code in td files.
With these 40 lines code, it process 9 operators more for C language and their
corresponding llvm IR instructions.
The arithmetic instructions are easy to implement by add the definition in td
file only.</p>
</div>
<div class="section" id="operator-not">
<h2>Operator “not” !<a class="headerlink" href="#operator-not" title="Permalink to this headline">¶</a></h2>
<p>Files ch4_2.cpp and ch4_2.bc are the C source code for <strong>“not”</strong> boolean operator
and it&#8217;s corresponding llvm IR. List them as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch4_2.cpp</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">b</span> <span class="o">=</span> <span class="o">!</span><span class="n">a</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch4_2.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-</span>
<span class="s2">f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;i386-apple-macosx10.8.0&quot;</span>

define i32 @main<span class="o">()</span> nounwind ssp <span class="o">{</span>
entry:
  %retval <span class="o">=</span> alloca i32, align 4
  %a <span class="o">=</span> alloca i32, align 4
  %b <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %retval
  store i32 5, i32* %a, align 4
  store i32 0, i32* %b, align 4
  %0 <span class="o">=</span> load i32* %a, align 4        // <span class="nv">a</span> <span class="o">=</span> %0
  %tobool <span class="o">=</span> icmp ne i32 %0, 0   // ne: stand <span class="k">for </span>not egual
  %lnot <span class="o">=</span> xor i1 %tobool, <span class="nb">true</span>
  %conv <span class="o">=</span> zext i1 %lnot to i32
  store i32 %conv, i32* %b, align 4
  %1 <span class="o">=</span> load i32* %b, align 4
  ret i32 %1
<span class="o">}</span>
</pre></div>
</div>
<p>As above comment, b = !a, translate to (xor (icmp ne i32 %0, 0), true).
The %0 is the virtual register of variable <strong>a</strong> and the result of
(icmp ne i32 %0, 0) is 1 bit size.
To prove the translation is correct.
Let&#8217;s assume %0 != 0 first, then the (icmp ne i32 %0, 0) = 1 (or true), and
(xor 1, 1) = 0.
When %0 = 0, (icmp ne i32 %0, 0) = 0 (or false), and (xor 0, 1) = 1.
So, the translation is correct.</p>
<p>Now, let&#8217;s run ch4_2.bc with 4/2/Cpu0 with llc -debug option to get result as
follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-16-22:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -debug -relocation-model<span class="o">=</span>pic
-filetype<span class="o">=</span>asm ch4_3.bc -o ch4_3.cpu0.s
...

<span class="o">===</span> main
Initial selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 20 nodes:
...
    0x7fbfc282c510: &lt;multiple use&gt;
          0x7fbfc282c510: &lt;multiple use&gt;
          0x7fbfc282bc10: &lt;multiple use&gt;
          0x7fbfc282c610: <span class="nv">ch</span> <span class="o">=</span> setne <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

        0x7fbfc282c710: <span class="nv">i1</span> <span class="o">=</span> setcc 0x7fbfc282c510, 0x7fbfc282bc10,
        0x7fbfc282c610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

        0x7fbfc282c810: <span class="nv">i1</span> <span class="o">=</span> Constant&lt;-1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

      0x7fbfc282c910: <span class="nv">i1</span> <span class="o">=</span> xor 0x7fbfc282c710, 0x7fbfc282c810 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

    0x7fbfc282ca10: <span class="nv">i32</span> <span class="o">=</span> zero_extend 0x7fbfc282c910 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

...


Replacing.3 0x7fbfc282c910: <span class="nv">i1</span> <span class="o">=</span> xor 0x7fbfc282c710, 0x7fbfc282c810 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

With: 0x7fbfc282ec10: <span class="nv">i1</span> <span class="o">=</span> setcc 0x7fbfc282c510, 0x7fbfc282bc10,
0x7fbfc282e910

Optimized lowered selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 17 nodes:
...
      0x7fbfc282c510: &lt;multiple use&gt;
          0x7fbfc282c510: &lt;multiple use&gt;
          0x7fbfc282bc10: &lt;multiple use&gt;
          0x7fbfc282e910: <span class="nv">ch</span> <span class="o">=</span> seteq

        0x7fbfc282ec10: <span class="nv">i1</span> <span class="o">=</span> setcc 0x7fbfc282c510, 0x7fbfc282bc10,
        0x7fbfc282e910

      0x7fbfc282ca10: <span class="nv">i32</span> <span class="o">=</span> zero_extend 0x7fbfc282ec10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>
…
Type-legalized selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 18 nodes:
...
      0x7fbfc282c510: &lt;multiple use&gt;
          0x7fbfc282c510: &lt;multiple use&gt;
          0x7fbfc282bc10: &lt;multiple use&gt;
          0x7fbfc282e910: <span class="nv">ch</span> <span class="o">=</span> seteq <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

        0x7fbfc282c610: <span class="nv">i32</span> <span class="o">=</span> setcc 0x7fbfc282c510, 0x7fbfc282bc10,
        0x7fbfc282e910 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

        0x7fbfc282c710: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

      0x7fbfc282c810: <span class="nv">i32</span> <span class="o">=</span> and 0x7fbfc282c610, 0x7fbfc282c710 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

 ...
</pre></div>
</div>
<p>The (setcc %1, %2, setne) and (xor %3, -1) in “Initial selection DAG” stage
corresponding (icmp %1, %2, ne) and (xor %3, 1) in ch4_2.bc.
The argument in xor is 1 bit size (1 and -1 are same, they are all represented
by 1).
The (zero_extend %4) of “Initial selection DAG” corresponding (zext i1 %lnot
to i32) of ch4_2.bc.
As above it translate 2 DAG nodes (setcc %1, %2, setne) and (xor %3, -1) into
1 DAG node (setcc %1, %2, seteq) in “Optimized lowered selection DAG” stage.
This translation is right since for 1 bit size, (xor %3, 1) and (not %3) has
same result, and (not (setcc %1, %2, setne)) is equal to (setcc %1, %2, seteq).
In “Optimized lowered selection DAG” stage, it also translate (zero_extern i1
%lnot to 32) into (and %lnot, 1).
(zero_extern i1 %lnot to 32) just expand the %lnot to i32 32 bits result, so
translate into (and %lnot, 1) is correct.
Finally, translate (setcc %1, %2, seteq) into (xor (xor %1, %2), (ldi $0, 1) in
“Instruction selection” stage by the rule defined in Cpu0InstrInfo.td as
follows,</p>
<div class="highlight-c++"><pre>//  Cpu0InstrInfo.td
...

def : Pat&lt;(not CPURegs:$in),
      (XOR CPURegs:$in, (LDI ZERO, 1))&gt;;

// setcc patterns
multiclass SeteqPats&lt;RegisterClass RC, Instruction XOROp,
                     Register ZEROReg&gt; {
  def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
            (XOROp (XOROp RC:$lhs, RC:$rhs), (LDI ZERO, 1))&gt;;
}

defm : SeteqPats&lt;CPURegs, XOR, ZERO&gt;;</pre>
</div>
<p>After xor, the (and %4, 1) is translated into (and $2, (ldi $3, 1)) which is
defined before already.
List the asm file ch4_3.cpu0.s code fragment as below, you can check it with
the final result.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-16-22:InputFiles Jonathan<span class="nv">$ </span>cat ch4_2.cpu0.s
...
<span class="c"># BB#0:                                 # %entry</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
    <span class="nv">$tmp1</span>:
            .cfi_def_cfa_offset 16
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
    st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, 5
    st  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    xor <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
    ldi <span class="nv">$3</span>, 1
    xor <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
    addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, 1
    and <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
    st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
    ret <span class="nv">$lr</span>
...
</pre></div>
</div>
</div>
<div class="section" id="display-llvm-ir-nodes-with-graphviz">
<h2>Display llvm IR nodes with Graphviz<a class="headerlink" href="#display-llvm-ir-nodes-with-graphviz" title="Permalink to this headline">¶</a></h2>
<p>The previous section, display the DAG translation process in text on terminal
by llc -debug option.
The llc also support the graphic display.
The <a class="reference external" href="http://jonathan2251.github.com/lbd/install.html#install-other-tools-on-imac">section Install other tools on iMac</a> mentioned the web for llc
graphic display information.
The llc graphic display with tool Graphviz is introduced in this section.
The graphic display is more readable by eye than display text in terminal.
It&#8217;s not necessary, but it help a lot especially when you are tired in tracking
the DAG translation process.
List the llc graphic support options from the sub-section &#8220;SelectionDAG
Instruction Selection Process&#8221; of web <a class="footnote-reference" href="#id9" id="id4">[4]</a> as follows,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The llc Graphviz DAG display options</p>
<p>-view-dag-combine1-dags displays the DAG after being built, before the
first optimization pass.</p>
<p>-view-legalize-dags displays the DAG before Legalization.</p>
<p>-view-dag-combine2-dags displays the DAG before the second optimization
pass.</p>
<p>-view-isel-dags displays the DAG before the Select phase.</p>
<p class="last">-view-sched-dags displays the DAG before Scheduling.</p>
</div>
<p>By tracking llc -debug, you can see the DAG translation steps as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>Initial selection DAG
Optimized lowered selection DAG
Type-legalized selection DAG
Optimized <span class="nb">type</span>-legalized selection DAG
Legalized selection DAG
Optimized legalized selection DAG
Instruction selection
Selected selection DAG
Scheduling
…
</pre></div>
</div>
<p>Let&#8217;s run llc with option -view-dag-combine1-dags, and open the output result
with Graphviz as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-12-177:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -view-dag-combine1-dags -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch4_2.bc -o ch4_2.cpu0.s
Writing <span class="s1">&#39;/tmp/llvm_84ibpm/dag.main.dot&#39;</span>...  <span class="k">done</span>.
118-165-12-177:InputFiles Jonathan<span class="nv">$ </span>Graphviz /tmp/llvm_84ibpm/dag.main.dot
</pre></div>
</div>
<p>It will show the /tmp/llvm_84ibpm/dag.main.dot as <a class="reference internal" href="#otherinst-f1"><em>llc option -view-dag-combine1-dags graphic view</em></a>.</p>
<div class="figure align-center" id="otherinst-f1">
<a class="reference internal image-reference" href="_images/113.png"><img alt="_images/113.png" src="_images/113.png" style="width: 687.0px; height: 851.0px;" /></a>
<p class="caption">Figure 1: llc option -view-dag-combine1-dags graphic view</p>
</div>
<p>From <a class="reference internal" href="#otherinst-f1"><em>llc option -view-dag-combine1-dags graphic view</em></a>, we can see the -view-dag-combine1-dags option is for
Initial selection DAG.
We list the other view options and their corresponding DAG translation stage as
follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>-view-dag-combine1-dags: Initial selection DAG
-view-legalize-dags: Optimized <span class="nb">type</span>-legalized selection DAG
-view-dag-combine2-dags: Legalized selection DAG
-view-isel-dags: Optimized legalized selection DAG
-view-sched-dags: Selected selection DAG
</pre></div>
</div>
<p>The -view-isel-dags is important and often used by an llvm backend writer
because it is the DAG before instruction selection.
The backend programmer need to know what is the DAG for writing the pattern
match instruction in target description file .td.</p>
</div>
<div class="section" id="adjust-cpu0-instructions">
<h2>Adjust cpu0 instructions<a class="headerlink" href="#adjust-cpu0-instructions" title="Permalink to this headline">¶</a></h2>
<p>We decide add instructions udiv and sra to avoid compiler errors for C language
operators <strong>“/”</strong> in unsigned int and <strong>“&gt;&gt;”</strong> in signed int as
<a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#support-arithmetic-instructions">section Support arithmetic instructions</a> mentioned.
To support these 2 operators, we only need to add these code in
Cpu0InstrInfo.td as follows,</p>
<div class="highlight-c++"><pre>//  Cpu0InstsInfo.td
...
def UDIV    : ArithLogicR&lt;0x17, "udiv", udiv, IIIdiv, CPURegs, 1&gt;;
…
/// Shift Instructions
// work, it's for ashr llvm IR instruction
def SRA     : shift_rotate_imm32&lt;0x1B, 0x00, "sra", sra&gt;;</pre>
</div>
<p>To use addiu only instead of ldi, change Cpu0InstrInfo.td as follows,</p>
<div class="highlight-c++"><pre>//  Cpu0InstsInfo.td
...
//def LDI     : MoveImm&lt;0x08, "ldi", add, simm16, immSExt16, CPURegs&gt;;
...
// setcc patterns
multiclass SeteqPats&lt;RegisterClass RC, Instruction XOROp&gt; {
  def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
      (XOROp (XOROp RC:$lhs, RC:$rhs), (ADDiu ZERO, 1))&gt;;
}

defm : SeteqPats&lt;CPURegs, XOR&gt;;</pre>
</div>
<p>Run ch4_4.cpp with code 4/4/Cpu0 which support udiv, sra, and use addiu only
instead of ldi, will get the result as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch4_4.cpp</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">f1</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-13-40:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_4.cpp -emit-llvm -o ch4_4.bc
118-165-13-40:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_4.bc -o ch4_4.cpu0.s
118-165-13-40:InputFiles Jonathan<span class="nv">$ </span>cat ch4_4.cpu0.s
    …
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
    ...
    udiv    <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
    st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    sra <span class="nv">$2</span>, <span class="nv">$2</span>, 2
    ...
</pre></div>
</div>
<div class="section" id="use-cpu0-official-ldi-instead-of-addiu">
<h3>Use cpu0 official LDI instead of ADDiu<a class="headerlink" href="#use-cpu0-official-ldi-instead-of-addiu" title="Permalink to this headline">¶</a></h3>
<p>According cpu0 web site instruction definition.
There is no addiu instruction definition.
We add <strong>addiu</strong> instruction because we find this instruction is more powerful
and reasonable than <strong>ldi</strong> instruction.
We highlight this change in <a class="reference external" href="http://jonathan2251.github.com/lbd/llvmstructure.html#cpu0-processor-architecture">section CPU0 processor architecture</a>.
Even with that, we show you how to replace our <strong>addiu</strong> with <strong>ldi</strong> according
the cpu0 original design.
4/4_2/Cpu0 is the code changes for use <strong>ldi</strong> instruction.
This changes replace <strong>addiu</strong> with <strong>ldi</strong> in Cpu0InstrInfo.td and modify
Cpu0FrameLowering.cpp as follows,</p>
<div class="highlight-c++"><pre>// Cpu0InstrInfo.td
…

/// Arithmetic Instructions (ALU Immediate)
def LDI     : MoveImm&lt;0x08, "ldi", add, simm16, immSExt16, CPURegs&gt;;
// add defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
//def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;
…

// Small immediates

def : Pat&lt;(i32 immSExt16:$in),
          (LDI ZERO, imm:$in)&gt;;

// hi/lo relocs
def : Pat&lt;(Cpu0Hi tglobaladdr:$in), (SHL (LDI ZERO, tglobaladdr:$in), 16)&gt;;
// Expect cpu0 add LUi support, like Mips
//def : Pat&lt;(Cpu0Hi tglobaladdr:$in), (LUi tglobaladdr:$in)&gt;;
def : Pat&lt;(Cpu0Lo tglobaladdr:$in), (LDI ZERO, tglobaladdr:$in)&gt;;

def : Pat&lt;(add CPURegs:$hi, (Cpu0Lo tglobaladdr:$lo)),
          (ADD CPURegs:$hi, (LDI ZERO, tglobaladdr:$lo))&gt;;

// gp_rel relocs
def : Pat&lt;(add CPURegs:$gp, (Cpu0GPRel tglobaladdr:$in)),
          (ADD CPURegs:$gp, (LDI ZERO, tglobaladdr:$in))&gt;;

def : Pat&lt;(not CPURegs:$in),
           (XOR CPURegs:$in, (LDI ZERO, 1))&gt;;

// Cpu0FrameLowering.cpp
...
void Cpu0FrameLowering::emitPrologue(MachineFunction &amp;MF) const {
  ...
  // Adjust stack.
  if (isInt&lt;16&gt;(-StackSize)) {
    // ldi fp, (-stacksize)
    // add sp, sp, fp
    BuildMI(MBB, MBBI, dl, TII.get(Cpu0::LDI), Cpu0::FP).addReg(Cpu0::FP)
                                                        .addImm(-StackSize);
    BuildMI(MBB, MBBI, dl, TII.get(Cpu0::ADD), SP).addReg(SP).addReg(Cpu0::FP);
  }
  …
}

void Cpu0FrameLowering::emitEpilogue(MachineFunction &amp;MF,
                                 MachineBasicBlock &amp;MBB) const {
  …
  // Adjust stack.
  if (isInt&lt;16&gt;(-StackSize)) {
    // ldi fp, (-stacksize)
    // add sp, sp, fp
    BuildMI(MBB, MBBI, dl, TII.get(Cpu0::LDI), Cpu0::FP).addReg(Cpu0::FP)
                                                        .addImm(-StackSize);
    BuildMI(MBB, MBBI, dl, TII.get(Cpu0::ADD), SP).addReg(SP).addReg(Cpu0::FP);
  }
  …
}</pre>
</div>
<p>As above code, we use <strong>add</strong> IR binary instruction (1 register operand and 1
immediate operand, and the register operand is fixed with ZERO) in our solution
since we didn&#8217;t find the <strong>move</strong> IR unary instruction.
This code is correct since all the immediate value is translated into
<strong>“ldi Zero, imm/address”</strong>.
And <strong>(add CPURegs:$gp, $imm16)</strong> is translated into
<strong>(ADD CPURegs:$gp, (LDI ZERO, $imm16))</strong>.
Let&#8217;s run 4/4_2/Cpu0 with ch4_4.cpp to get the correct result
below.
As you will see, <strong>“addiu $sp, $sp, -24”</strong> will be replaced with the pair
instructions of <strong>“ldi $fp, -24”</strong> and <strong>“add $sp, $sp, $fp”</strong>.
Since the $sp pointer adjustment is so frequently occurs (it occurs in every
function entry and exit point),
we reserve the $fp to the pair of stack adjustment instructions <strong>“ldi”</strong> and
<strong>“add”</strong>.
If we didn&#8217;t reserve the dedicate registers $fp and $sp, it need to save
and restore them in the stack adjustment.
It meaning more instructions running cost in this.
Anyway, the pair of <strong>“ldi”</strong> and <strong>“add”</strong> to adjust stack pointer is double
in cost compete to <strong>“addiu”</strong>, that&#8217;s the benefit we mentioned in
<a class="reference external" href="http://jonathan2251.github.com/lbd/llvmstructure.html#cpu0-processor-architecture">section CPU0 processor architecture</a>.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/cmake_
debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_4.bc -o ch4_4.cpu0.s
118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>cat ch4_4.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch4_4.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,24,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  ldi <span class="nv">$fp</span>, -24
  add <span class="nv">$sp</span>, <span class="nv">$sp</span>, <span class="nv">$fp</span>
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 24
  ldi <span class="nv">$2</span>, 0
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ldi <span class="nv">$3</span>, 1
  st  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ldi <span class="nv">$3</span>, 2
  st  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ldi <span class="nv">$3</span>, -5
  st  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  udiv  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sra <span class="nv">$2</span>, <span class="nv">$2</span>, 2
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ldi <span class="nv">$fp</span>, 24
  add <span class="nv">$sp</span>, <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
</div>
</div>
<div class="section" id="local-variable-pointer">
<h2>Local variable pointer<a class="headerlink" href="#local-variable-pointer" title="Permalink to this headline">¶</a></h2>
<p>To support pointer to local variable, add this code fragment in
Cpu0InstrInfo.td and Cpu0InstPrinter.cpp as follows,</p>
<div class="highlight-c++"><pre>// Cpu0InstrInfo.td
...
def mem_ea : Operand&lt;i32&gt; {
  let PrintMethod = "printMemOperandEA";
  let MIOperandInfo = (ops CPURegs, simm16);
  let EncoderMethod = "getMemEncoding";
}
...
class EffectiveAddress&lt;string instr_asm, RegisterClass RC, Operand Mem&gt; :
  FMem&lt;0x09, (outs RC:$ra), (ins Mem:$addr),
     instr_asm, [(set RC:$ra, addr:$addr)], IIAlu&gt;;
...
// FrameIndexes are legalized when they are operands from load/store
// instructions. The same not happens for stack address copies, so an
// add op with mem ComplexPattern is used and the stack address copy
// can be matched. It's similar to Sparc LEA_ADDRi
def LEA_ADDiu : EffectiveAddress&lt;"addiu\t$ra, $addr", CPURegs, mem_ea&gt; {
  let isCodeGenOnly = 1;
}

// Cpu0InstPrinter.cpp
...
void Cpu0InstPrinter::
printMemOperandEA(const MCInst *MI, int opNum, raw_ostream &amp;O) {
  // when using stack locations for not load/store instructions
  // print the same way as all normal 3 operand instructions.
  printOperand(MI, opNum, O);
  O &lt;&lt; ", ";
  printOperand(MI, opNum+1, O);
  return;
}</pre>
</div>
<p>Run ch4_5.cpp with code 4/5/Cpu0 which support pointer to local variable,
will get result as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch4_5.cpp</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_5.cpp -emit-llvm -o ch4_5.bc
118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/cmake_
debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_5.bc -o ch4_5.cpu0.s
118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>cat ch4_5.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch4_5.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,16,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 16
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 8
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
</div>
<div class="section" id="operator-mod">
<h2>Operator mod, %<a class="headerlink" href="#operator-mod" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-dag-of">
<h3>The DAG of %<a class="headerlink" href="#the-dag-of" title="Permalink to this headline">¶</a></h3>
<p>Example input code ch4_6.cpp which contains the C operator <strong>“%”</strong> and it&#8217;s
corresponding llvm IR, as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch4_6.cpp</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
  <span class="c1">//  unsigned int b = 11;</span>

  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">12</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch4_6.bc&#39;</span>
 target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-</span>
<span class="s2"> f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;i386-apple-macosx10.8.0&quot;</span>

define i32 @main<span class="o">()</span> nounwind ssp <span class="o">{</span>
entry:
  %retval <span class="o">=</span> alloca i32, align 4
  %b <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %retval
  store i32 11, i32* %b, align 4
  %0 <span class="o">=</span> load i32* %b, align 4
  %add <span class="o">=</span> add nsw i32 %0, 1
  %rem <span class="o">=</span> srem i32 %add, 12
  store i32 %rem, i32* %b, align 4
  %1 <span class="o">=</span> load i32* %b, align 4
  ret i32 %1
<span class="o">}</span>
</pre></div>
</div>
<p>LLVM <strong>srem</strong> is the IR corresponding <strong>“%”</strong>, reference sub-section &#8220;srem instruction&#8221;
of <a class="footnote-reference" href="#id8" id="id5">[3]</a>.
Copy the reference as follows,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>&#8216;srem&#8217;</strong> Instruction</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><strong>&lt;result&gt; = srem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields {ty}:result</strong></dd>
</dl>
<p>Overview:
The <strong>&#8216;srem&#8217;</strong> instruction returns the remainder from the signed division of its
two operands. This instruction can also take vector versions of the values in
which case the elements must be integers.</p>
<p>Arguments:
The two arguments to the <strong>&#8216;srem&#8217;</strong> instruction must be integer or vector of
integer values. Both arguments must have identical types.</p>
<p>Semantics:
This instruction returns the remainder of a division (where the result is
either zero or has the same sign as the dividend, op1), not the modulo operator
(where the result is either zero or has the same sign as the divisor, op2) of
a value. For more information about the difference, see The Math Forum. For a
table of how this is implemented in various languages, please see Wikipedia:
modulo operation.</p>
<p>Note that signed integer remainder and unsigned integer remainder are distinct
operations; for unsigned integer remainder, use <strong>&#8216;urem&#8217;</strong>.</p>
<p>Taking the remainder of a division by zero leads to undefined behavior.
Overflow also leads to undefined behavior; this is a rare case, but can occur,
for example, by taking the remainder of a 32-bit division of -2147483648 by -1.
(The remainder doesn&#8217;t actually overflow, but this rule lets srem be
implemented using instructions that return both the result of the division and
the remainder.)</p>
<dl class="last docutils">
<dt>Example:</dt>
<dd>&lt;result&gt; = <strong>srem i32 4, %var</strong>          ; yields {i32}:result = 4 % %var</dd>
</dl>
</div>
<p>Run 4/5/Cpu0 with input file ch4_6.bc and <tt class="docutils literal"><span class="pre">llc</span></tt> option –view-isel-dags as
follows, will get the error message as follows and the llvm DAG of
<a class="reference internal" href="#otherinst-f2"><em>ch4_6.bc DAG</em></a>.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-37:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -view-isel-dags -relocation-model<span class="o">=</span>
pic -filetype<span class="o">=</span>asm ch4_6.bc -o ch4_6.cpu0.s
...
LLVM ERROR: Cannot <span class="k">select</span>: 0x7fa73a02ea10: <span class="nv">i32</span> <span class="o">=</span> mulhs 0x7fa73a02c610,
0x7fa73a02e910 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>12<span class="o">]</span>
  0x7fa73a02c610: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>
  0x7fa73a02e910: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;715827883&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
</pre></div>
</div>
<div class="figure align-center" id="otherinst-f2">
<a class="reference internal image-reference" href="_images/25.png"><img alt="_images/25.png" src="_images/25.png" style="width: 778.0px; height: 786.0px;" /></a>
<p class="caption">Figure 2: ch4_6.bc DAG</p>
</div>
<p>LLVM replace srem divide operation with multiply operation in DAG optimization
because DIV operation cost more in time than MUL.
For example code <strong>“int b = 11; b=(b+1)%12;”</strong>, it translate into <a class="reference internal" href="#otherinst-f2"><em>ch4_6.bc DAG</em></a>.
We verify the result and explain by calculate the value in each node.
The 0xC*0x2AAAAAAB=0x200000004, (mulhs 0xC, 0x2AAAAAAAB) meaning get the Signed
mul high word (32bits).
Multiply with 2 operands of 1 word size generate the 2 word size of result
(0x2, 0xAAAAAAAB).
The high word result, in this case is 0x2.
The final result (sub 12, 12) is 0 which match the statement (11+1)%12.</p>
</div>
<div class="section" id="arm-solution">
<h3>Arm solution<a class="headerlink" href="#arm-solution" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s run 4/6_1/Cpu0 with ch4_6.cpp as well as llc option  -view-sched-dags to
get <a class="reference internal" href="#otherinst-f3"><em>Translate ch4_6.bc into cpu0 backend DAG</em></a>.
Similarly, SMMUL get the high word of multiply result.</p>
<div class="figure align-center" id="otherinst-f3">
<a class="reference internal image-reference" href="_images/34.png"><img alt="_images/34.png" src="_images/34.png" style="width: 657.0px; height: 781.0px;" /></a>
<p class="caption">Figure 3: Translate ch4_6.bc into cpu0 backend DAG</p>
</div>
<p>Follows is the result of run 4/6_1/Cpu0 with ch4_6.bc.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/cmake_
debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_6.bc -o ch4_6.cpu0.s
118-165-71-252:InputFiles Jonathan<span class="nv">$ </span>cat ch4_6.cpu0.s
    .section .mdebug.abi32
    .previous
    .file   <span class="s2">&quot;ch4_6.bc&quot;</span>
    .text
    .globl  main
    .align  2
    .type   main,@function
    .ent    main                    <span class="c"># @main</span>
main:
    .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
    .mask   0x00000000,0
    .set    noreorder
    .set    nomacro
<span class="c"># BB#0:                                 # %entry</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
    st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 11
    st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 10922
    shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
    addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, 43691
    or  <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 12
    smmul   <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
    shr <span class="nv">$4</span>, <span class="nv">$3</span>, 31
    sra <span class="nv">$3</span>, <span class="nv">$3</span>, 1
    add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
    mul <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
    sub <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
    st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
    ret <span class="nv">$lr</span>
    .set    macro
    .set    reorder
    .end    main
<span class="nv">$tmp1</span>:
    .size   main, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-main
</pre></div>
</div>
<p>The other instruction UMMUL and llvm IR mulhu are unsigned int type for
operator %.
You can check it by unmark the <strong>“unsigned int b = 11;”</strong> in ch4_6.cpp.</p>
<p>Use SMMUL instruction to get the high word of multiplication result is adopted
in ARM.
The 4/6_1/Cpu0 use the ARM solution.
With this solution, the following code is needed.</p>
<div class="highlight-c++"><pre>// Cpu0InstrInfo.td
…
// Transformation Function - get the lower 16 bits.
def LO16 : SDNodeXForm&lt;imm, [{
  return getImm(N, N-&gt;getZExtValue() &amp; 0xFFFF);
}]&gt;;

// Transformation Function - get the higher 16 bits.
def HI16 : SDNodeXForm&lt;imm, [{
  return getImm(N, (N-&gt;getZExtValue() &gt;&gt; 16) &amp; 0xFFFF);
}]&gt;;
…
def SMMUL   : ArithLogicR&lt;0x50, "smmul", mulhs, IIImul, CPURegs, 1&gt;;
def UMMUL   : ArithLogicR&lt;0x51, "ummul", mulhu, IIImul, CPURegs, 1&gt;;
…
// Arbitrary immediates
def : Pat&lt;(i32 imm:$imm),
      (OR (SHL (ADDiu ZERO, (HI16 imm:$imm)), 16), (ADDiu ZERO, (LO16 imm:$imm)))&gt;;</pre>
</div>
</div>
<div class="section" id="mips-solution">
<h3>Mips solution<a class="headerlink" href="#mips-solution" title="Permalink to this headline">¶</a></h3>
<p>Mips use MULT instruction and save the high &amp; low part to register HI and LO.
After that, use mfhi/mflo to move register HI/LO to your general purpose
register.
ARM SMMUL is fast if you only need the HI part of result (it ignore the LO part
of operation).
Meanwhile Mips is fast if you need both the HI and LO result.
If you need the LO part of result, you can use Cpu0 MUL instruction which only
get the LO part of result.
4/6_2/Cpu0 is implemented with Mips MULT style.
We choose it as the implementation of this book.
For Mips style implementation, we add the following code in
Cpu0RegisterInfo.td, Cpu0InstrInfo.td and Cpu0ISelDAGToDAG.cpp.
And list the related DAG nodes mulhs and mulhu which are used in 4/6_2/Cpu0
from TargetSelectionDAG.td.</p>
<div class="highlight-c++"><pre>// Cpu0RegisterInfo.td
  ...
  // Hi/Lo registers
  def HI  : Register&lt;"hi"&gt;, DwarfRegNum&lt;[18]&gt;;
    def LO  : Register&lt;"lo"&gt;, DwarfRegNum&lt;[19]&gt;;

// Cpu0Schedule.td
...
def IIHiLo             : InstrItinClass;
...
def Cpu0GenericItineraries : ProcessorItineraries&lt;[ALU, IMULDIV], [], [
  ...
  InstrItinData&lt;IIHiLo             , [InstrStage&lt;1,  [IMULDIV]&gt;]&gt;,
  …
]&gt;;

// Cpu0InstrInfo.td
...
// Mul, Div
class Mult&lt;bits&lt;8&gt; op, string instr_asm, InstrItinClass itin,
           RegisterClass RC, list&lt;Register&gt; DefRegs&gt;:
  FL&lt;op, (outs), (ins RC:$ra, RC:$rb),
      !strconcat(instr_asm, "\t$ra, $rb"), [], itin&gt; {
  let imm16 = 0;
  let isCommutable = 1;
  let Defs = DefRegs;
  let neverHasSideEffects = 1;
}

class Mult32&lt;bits&lt;8&gt; op, string instr_asm, InstrItinClass itin&gt;:
  Mult&lt;op, instr_asm, itin, CPURegs, [HI, LO]&gt;;

// Move from Hi/Lo
class MoveFromLOHI&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
                 list&lt;Register&gt; UseRegs&gt;:
  FL&lt;op, (outs RC:$ra), (ins),
     !strconcat(instr_asm, "\t$ra"), [], IIHiLo&gt; {
  let rb = 0;
  let imm16 = 0;
  let Uses = UseRegs;
  let neverHasSideEffects = 1;
}
...
def MULT    : Mult32&lt;0x50, "mult", IIImul&gt;;
def MULTu   : Mult32&lt;0x51, "multu", IIImul&gt;;

def MFHI : MoveFromLOHI&lt;0x40, "mfhi", CPURegs, [HI]&gt;;
def MFLO : MoveFromLOHI&lt;0x41, "mflo", CPURegs, [LO]&gt;;

// Cpu0ISelDAGToDAG.cpp
...
/// Select multiply instructions.
std::pair&lt;SDNode*, SDNode*&gt;
Cpu0DAGToDAGISel::SelectMULT(SDNode *N, unsigned Opc, DebugLoc dl, EVT Ty,
                              bool HasLo, bool HasHi) {
  SDNode *Lo = 0, *Hi = 0;
  SDNode *Mul = CurDAG-&gt;getMachineNode(Opc, dl, MVT::Glue, N-&gt;getOperand(0),
                                        N-&gt;getOperand(1));
  SDValue InFlag = SDValue(Mul, 0);

  if (HasLo) {
    Lo = CurDAG-&gt;getMachineNode(Cpu0::MFLO, dl,
                                Ty, MVT::Glue, InFlag);
    InFlag = SDValue(Lo, 1);
  }
  if (HasHi)
    Hi = CurDAG-&gt;getMachineNode(Cpu0::MFHI, dl,
                                  Ty, InFlag);

  return std::make_pair(Lo, Hi);
}

/// Select instructions not customized! Used for
/// expanded, promoted and normal instructions
SDNode* Cpu0DAGToDAGISel::Select(SDNode *Node) {
  unsigned Opcode = Node-&gt;getOpcode();
  ...
  switch(Opcode) {
  default: break;

  case ISD::MULHS:
  case ISD::MULHU: {
    MultOpc = (Opcode == ISD::MULHU ? Cpu0::MULTu : Cpu0::MULT);
    return SelectMULT(Node, MultOpc, dl, NodeTy, false, true).second;
  }
  ...
}

// TargetSelectionDAG.td
...
def mulhs      : SDNode&lt;"ISD::MULHS"     , SDTIntBinOp, [SDNPCommutative]&gt;;
def mulhu      : SDNode&lt;"ISD::MULHU"     , SDTIntBinOp, [SDNPCommutative]&gt;;</pre>
</div>
<p>Except the custom type, llvm IR operations of expand and promote type will call
Cpu0DAGToDAGISel::Select() during instruction selection of DAG translation.
In Select(), it return the HI part of multiplication result to HI register,
for IR operations of mulhs or mulhu.
After that, MFHI instruction move the HI register to cpu0 field &#8220;a&#8221; register,
$ra.
MFHI instruction is FL format and only use cpu0 field &#8220;a&#8221; register, we set
the $rb and imm16 to 0.
<a class="reference internal" href="#otherinst-f4"><em>DAG for ch4_6.bc with Mips style MULT</em></a> and ch4_6.cpu0.s are the result of compile ch4_6.bc.</p>
<div class="figure align-center" id="otherinst-f4">
<a class="reference internal image-reference" href="_images/43.png"><img alt="_images/43.png" src="_images/43.png" style="width: 231.75px; height: 605.25px;" /></a>
<p class="caption">Figure 4: DAG for ch4_6.bc with Mips style MULT</p>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>cat ch4_6.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch4_6.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 11
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 10922
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 43691
  or  <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 12
  mult  <span class="nv">$2</span>, <span class="nv">$3</span>
  mfhi  <span class="nv">$3</span>
  shr <span class="nv">$4</span>, <span class="nv">$3</span>, 31
  sra <span class="nv">$3</span>, <span class="nv">$3</span>, 1
  add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  mul <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  sub <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
</div>
</div>
<div class="section" id="full-support">
<h2>Full support %<a class="headerlink" href="#full-support" title="Permalink to this headline">¶</a></h2>
<p>The sensitive readers may find the llvm using <strong>“multiplication”</strong> instead
of <strong>“div”</strong> to get the <strong>“%”</strong> result just because our example use constant as
divider, <strong>“(b+1)%12”</strong> in our example.
If programmer use variable as the divider like <strong>“(b+1)%a”</strong>, then what will
happens in our code.
The answer is our code will have error to take care this.
In <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#support-arithmetic-instructions">section Support arithmetic instructions</a>, we use <strong>“div a, b”</strong>
to hold the quotient part in register.
The multiplication operator <strong>“*”</strong> need 64 bits of register to hold the result
for two 32 bits of operands multiplication.
We modify cpu0 to use the pair of registers LO and HI which just like Mips to
solve this issue in last section.
Now, it&#8217;s time to modify cpu0 for integer <strong>“divide”</strong> operator again.
We use LO and HI registers to hold the <strong>&#8220;quotient&#8221;</strong> and <strong>&#8220;remainder&#8221;</strong> and
use instructions <strong>“mflo”</strong> and <strong>“mfhi”</strong> to get the result from LO or HI
registers.
With this solution, the <strong>“c = a / b”</strong> can be got by <strong>“div a, b”</strong> and
<strong>“mflo c”</strong>; the <strong>“c = a % b”</strong> can be got by <strong>“div a, b”</strong> and <strong>“mfhi c”</strong>.</p>
<p>4/6_4/Cpu0 support operator <strong>“%”</strong> and <strong>“/”</strong>.
The code added in 4/6_4/Cpu0 as follows,</p>
<div class="highlight-c++"><pre>// Cpu0InstrInfo.cpp
...
void Cpu0InstrInfo::
copyPhysReg(MachineBasicBlock &amp;MBB,
      MachineBasicBlock::iterator I, DebugLoc DL,
      unsigned DestReg, unsigned SrcReg,
      bool KillSrc) const {
  unsigned Opc = 0, ZeroReg = 0;

  if (Cpu0::CPURegsRegClass.contains(DestReg)) { // Copy to CPU Reg.
  if (Cpu0::CPURegsRegClass.contains(SrcReg))
    Opc = Cpu0::ADD, ZeroReg = Cpu0::ZERO;
  else if (SrcReg == Cpu0::HI)
    Opc = Cpu0::MFHI, SrcReg = 0;
  else if (SrcReg == Cpu0::LO)
    Opc = Cpu0::MFLO, SrcReg = 0;
  }
  else if (Cpu0::CPURegsRegClass.contains(SrcReg)) { // Copy from CPU Reg.
  if (DestReg == Cpu0::HI)
    Opc = Cpu0::MTHI, DestReg = 0;
  else if (DestReg == Cpu0::LO)
    Opc = Cpu0::MTLO, DestReg = 0;
  }

  assert(Opc &amp;&amp; "Cannot copy registers");

  MachineInstrBuilder MIB = BuildMI(MBB, I, DL, get(Opc));

  if (DestReg)
  MIB.addReg(DestReg, RegState::Define);

  if (ZeroReg)
  MIB.addReg(ZeroReg);

  if (SrcReg)
  MIB.addReg(SrcReg, getKillRegState(KillSrc));
}

// Cpu0InstrInfo.h
...
  virtual void copyPhysReg(MachineBasicBlock &amp;MBB,
               MachineBasicBlock::iterator MI, DebugLoc DL,
               unsigned DestReg, unsigned SrcReg,
               bool KillSrc) const;

// Cpu0InstrInfo.td
...
def SDT_Cpu0DivRem       : SDTypeProfile&lt;0, 2,
                     [SDTCisInt&lt;0&gt;,
                      SDTCisSameAs&lt;0, 1&gt;]&gt;;
...
// DivRem(u) nodes
def Cpu0DivRem    : SDNode&lt;"Cpu0ISD::DivRem", SDT_Cpu0DivRem,
               [SDNPOutGlue]&gt;;
def Cpu0DivRemU   : SDNode&lt;"Cpu0ISD::DivRemU", SDT_Cpu0DivRem,
               [SDNPOutGlue]&gt;;
...
class Div&lt;SDNode opNode, bits&lt;8&gt; op, string instr_asm, InstrItinClass itin,
      RegisterClass RC, list&lt;Register&gt; DefRegs&gt;:
  FL&lt;op, (outs), (ins RC:$rb, RC:$rc),
   !strconcat(instr_asm, "\t$$zero, $rb, $rc"),
   [(opNode RC:$rb, RC:$rc)], itin&gt; {
  let imm16 = 0;
  let Defs = DefRegs;
}

class Div32&lt;SDNode opNode, bits&lt;8&gt; op, string instr_asm, InstrItinClass itin&gt;:
  Div&lt;opNode, op, instr_asm, itin, CPURegs, [HI, LO]&gt;;
…
class MoveToLOHI&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
         list&lt;Register&gt; DefRegs&gt;:
  FL&lt;op, (outs), (ins RC:$ra),
   !strconcat(instr_asm, "\t$ra"), [], IIHiLo&gt; {
  let rb = 0;
  let imm16 = 0;
  let Defs = DefRegs;
  let neverHasSideEffects = 1;
}
...
def SDIV    : Div32&lt;Cpu0DivRem, 0x16, "div", IIIdiv&gt;;
def UDIV    : Div32&lt;Cpu0DivRemU, 0x17, "divu", IIIdiv&gt;;
…
def MTHI : MoveToLOHI&lt;0x42, "mthi", CPURegs, [HI]&gt;;
def MTLO : MoveToLOHI&lt;0x43, "mtlo", CPURegs, [LO]&gt;;

// Cpu0ISelLowering.cpp
…
Cpu0TargetLowering::
Cpu0TargetLowering(Cpu0TargetMachine &amp;TM)
  : TargetLowering(TM, new TargetLoweringObjectFileELF()),
  Subtarget(&amp;TM.getSubtarget&lt;Cpu0Subtarget&gt;()) {
  ...
  setOperationAction(ISD::SDIV, MVT::i32, Expand);
  setOperationAction(ISD::SREM, MVT::i32, Expand);
  setOperationAction(ISD::UDIV, MVT::i32, Expand);
  setOperationAction(ISD::UREM, MVT::i32, Expand);

  setTargetDAGCombine(ISD::SDIVREM);
  setTargetDAGCombine(ISD::UDIVREM);
  ...
}
...
static SDValue PerformDivRemCombine(SDNode *N, SelectionDAG&amp; DAG,
                  TargetLowering::DAGCombinerInfo &amp;DCI,
                  const Cpu0Subtarget* Subtarget) {
  if (DCI.isBeforeLegalizeOps())
  return SDValue();

  EVT Ty = N-&gt;getValueType(0);
  unsigned LO = Cpu0::LO;
  unsigned HI = Cpu0::HI;
  unsigned opc = N-&gt;getOpcode() == ISD::SDIVREM ? Cpu0ISD::DivRem :
                          Cpu0ISD::DivRemU;
  DebugLoc dl = N-&gt;getDebugLoc();

  SDValue DivRem = DAG.getNode(opc, dl, MVT::Glue,
                 N-&gt;getOperand(0), N-&gt;getOperand(1));
  SDValue InChain = DAG.getEntryNode();
  SDValue InGlue = DivRem;

  // insert MFLO
  if (N-&gt;hasAnyUseOfValue(0)) {
  SDValue CopyFromLo = DAG.getCopyFromReg(InChain, dl, LO, Ty,
                      InGlue);
  DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), CopyFromLo);
  InChain = CopyFromLo.getValue(1);
  InGlue = CopyFromLo.getValue(2);
  }

  // insert MFHI
  if (N-&gt;hasAnyUseOfValue(1)) {
  SDValue CopyFromHi = DAG.getCopyFromReg(InChain, dl,
                      HI, Ty, InGlue);
  DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), CopyFromHi);
  }

  return SDValue();
}

SDValue Cpu0TargetLowering::PerformDAGCombine(SDNode *N, DAGCombinerInfo &amp;DCI)
  const {
  SelectionDAG &amp;DAG = DCI.DAG;
  unsigned opc = N-&gt;getOpcode();

  switch (opc) {
  default: break;
  case ISD::SDIVREM:
  case ISD::UDIVREM:
  return PerformDivRemCombine(N, DAG, DCI, Subtarget);
  }

  return SDValue();
}

// Cpu0ISelLowering.h
…
namespace llvm {
  namespace Cpu0ISD {
  enum NodeType {
    // Start the numbering from where ISD NodeType finishes.
    FIRST_NUMBER = ISD::BUILTIN_OP_END,
    Ret,
    // DivRem(u)
    DivRem,
    DivRemU
  };
  }
…

// Cpu0RegisterInfo.td
...
// Hi/Lo Registers
def HILO : RegisterClass&lt;"Cpu0", [i32], 32, (add HI, LO)&gt;;</pre>
</div>
<p>Run with ch4_1_2.cpp can get the result for operator <strong>“/”</strong> as below.
But run with ch4_6_1.cpp as below, cannot get the <strong>“div”</strong> for operator
<strong>“%”</strong>.
It still use <strong>&#8220;multiplication&#8221;</strong> instead of <strong>&#8220;div&#8221;</strong> because llvm do
<strong>“Constant Propagation Optimization”</strong> in this.
The ch4_6_2.cpp can get the <strong>“div”</strong> for <strong>“%”</strong> result since it make the
llvm <strong>“Constant Propagation Optimization”</strong> useless in this.
Unfortunately, we cannot run it now since it need the function call support.
We will verify <strong>“%”</strong> with ch4_6_2.cpp at the end of chapter “Function Call”.
You can run with the end of Example Code of chapter “Function Call”, if you
like to verify it now.</p>
<div class="highlight-c++"><pre>// ch4_1_2.cpp
int main()
{
  …
  f = a / b;
  …
}</pre>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-77-79:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_1_2.cpp -emit-llvm -o ch4_1_2.bc
118-165-77-79:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/cmake_
debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_1_2.bc -o ch4_1_2.cpu0.s
118-165-77-79:InputFiles Jonathan<span class="nv">$ </span>cat ch4_1_2.cpu0.s
  div <span class="nv">$zero</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  mflo  <span class="nv">$2</span>
  …

// ch4_6_1.cpp
int main<span class="o">()</span>
<span class="o">{</span>
  int <span class="nv">b</span> <span class="o">=</span> 11;
  int <span class="nv">a</span> <span class="o">=</span> 12;

  <span class="nv">b</span> <span class="o">=</span> <span class="o">(</span>b+1<span class="o">)</span>%a;

  <span class="k">return </span>b;
<span class="o">}</span>

// ch4_6_2.cpp
<span class="c">#include &lt;stdlib.h&gt;</span>

int main<span class="o">()</span>
<span class="o">{</span>
  int <span class="nv">b</span> <span class="o">=</span> 11;
//  unsigned int <span class="nv">b</span> <span class="o">=</span> 11;
  int <span class="nv">c</span> <span class="o">=</span> rand<span class="o">()</span>;

  <span class="nv">b</span> <span class="o">=</span> <span class="o">(</span>b+1<span class="o">)</span>%c;

  <span class="k">return </span>b;
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>We support most of C operators in this chapter.
Until now, we have around 3400 lines of source code with comments.
With these 345 lines of source code added, it support the number of operators
from three to over ten.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html">http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://msdn.microsoft.com/en-us/library/336xbhcz%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-us/library/336xbhcz%28v=vs.80%29.aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Other instructions</a><ul>
<li><a class="reference internal" href="#support-arithmetic-instructions">Support arithmetic instructions</a></li>
<li><a class="reference internal" href="#operator-not">Operator “not” !</a></li>
<li><a class="reference internal" href="#display-llvm-ir-nodes-with-graphviz">Display llvm IR nodes with Graphviz</a></li>
<li><a class="reference internal" href="#adjust-cpu0-instructions">Adjust cpu0 instructions</a><ul>
<li><a class="reference internal" href="#use-cpu0-official-ldi-instead-of-addiu">Use cpu0 official LDI instead of ADDiu</a></li>
</ul>
</li>
<li><a class="reference internal" href="#local-variable-pointer">Local variable pointer</a></li>
<li><a class="reference internal" href="#operator-mod">Operator mod, %</a><ul>
<li><a class="reference internal" href="#the-dag-of">The DAG of %</a></li>
<li><a class="reference internal" href="#arm-solution">Arm solution</a></li>
<li><a class="reference internal" href="#mips-solution">Mips solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#full-support">Full support %</a></li>
<li><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="backendstructure.html"
                        title="previous chapter">LLVM Backend Structure</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="genobj.html"
                        title="next chapter">Generate obj file</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/otherinst.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="genobj.html" title="Generate obj file"
             >next</a> |</li>
        <li class="right" >
          <a href="backendstructure.html" title="LLVM Backend Structure"
             >previous</a> |</li>
        <li><a href="index.html">Write An LLVM Backend Tutorial For Cpu0</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>