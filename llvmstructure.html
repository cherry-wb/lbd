

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cpu0 Instruction and LLVM Target Description &mdash; Write An LLVM Backend Tutorial For Cpu0</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Write An LLVM Backend Tutorial For Cpu0" href="index.html" />
    <link rel="next" title="LLVM Backend Structure" href="backendstructure.html" />
    <link rel="prev" title="Getting Started: Installing LLVM and the Cpu0 example code" href="install.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="backendstructure.html" title="LLVM Backend Structure"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="install.html" title="Getting Started: Installing LLVM and the Cpu0 example code"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Write An LLVM Backend Tutorial For Cpu0</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cpu0-instruction-and-llvm-target-description">
<h1>Cpu0 Instruction and LLVM Target Description<a class="headerlink" href="#cpu0-instruction-and-llvm-target-description" title="Permalink to this headline">¶</a></h1>
<p>Before you start, you should know that you can always examine existing LLVM
backend code and attempt to port what you find for your own target architecture
.  The majority of this code can be found in the /lib/Target directory of your
root LLVM directory. As most major RISC instruction set architectures have some
similarities, this may be the avenue you might try if you are both an
experienced programmer and knowledgable of compiler backends.
However, there is a steep learning curve and you may easily get held up
debugging your new backend. You can easily spend a lot of time tracing which
methods are callbacks of some function, or which are calling some overridden
method deep in the LLVM codebase - and with a codebase as large as LLVM, this
can easily become a headache. This tutorial will help you work through this
process while learning the fundamentals of LLVM backend design. It will show
you what is necessary to get your first backend functional and complete, and it
should help you understand how to debug your backend when it does not produce
desirable output using the output provided by LLVM.</p>
<p>This chapter shows you the cpu0 instruction format first.
Next, the llvm structure is introduced to you by copy and paste the related
article from llvm web site. The llvm structure introduced here is extracted
from the asop web site. You can read the whole article from the asop web site.
After that we will show you how to write register and instruction definitions
(Target Description File) which will be used in next chapter.</p>
<div class="section" id="cpu0-processor-architecture">
<h2>CPU0 processor architecture<a class="headerlink" href="#cpu0-processor-architecture" title="Permalink to this headline">¶</a></h2>
<p>We copy and redraw figures in english in this section. This
web site <a class="footnote-reference" href="#id10" id="id1">[1]</a> is chinese version and here <a class="footnote-reference" href="#id11" id="id2">[2]</a> is english version.</p>
<div class="section" id="brief-introduction">
<h3>Brief introduction<a class="headerlink" href="#brief-introduction" title="Permalink to this headline">¶</a></h3>
<p>CPU0 is a 32-bit processor which has registers R0 .. R15, IR, MAR, MDR, etc.,
and its structure is shown below.</p>
<div class="figure align-center" id="llvmstructure-f1">
<img alt="_images/112.png" src="_images/112.png" />
<p class="caption">Figure 1: The structure of the processor of CPU0</p>
</div>
<p>Uses of each register as follows:</p>
<div class="figure align-center" id="llvmstructure-t1">
<img alt="_images/113.png" src="_images/113.png" />
<p class="caption">Figure 2: Cpu0 registers table</p>
</div>
</div>
<div class="section" id="instruction-set-for-cpu0">
<h3>Instruction Set for CPU0<a class="headerlink" href="#instruction-set-for-cpu0" title="Permalink to this headline">¶</a></h3>
<p>The CPU0 instruction divided into three types, L-type usually load the saved
instruction, A-type arithmetic instruction-based J-type usually jump
instruction, the following figure shows the three types of instruction encoding
format.</p>
<div class="figure align-center" id="llvmstructure-f2">
<img alt="_images/24.png" src="_images/24.png" />
<p class="caption">Figure 3: CPU0 three instruction formats</p>
</div>
<p>The following is the CPU0 processor&#8217;s instruction table format</p>
<div class="figure align-center" id="llvmstructure-t2">
<img alt="_images/25.png" src="_images/25.png" />
<p class="caption">Figure 4: CPU0 instruction table</p>
</div>
<p>In the second edition of CPU0_v2 we fill the following command:</p>
<div class="figure align-center" id="llvmstructure-t3">
<img alt="_images/33.png" src="_images/33.png" />
<p class="caption">Figure 5: CPU0_v2 instruction table</p>
</div>
</div>
<div class="section" id="status-register">
<h3>Status register<a class="headerlink" href="#status-register" title="Permalink to this headline">¶</a></h3>
<p>CPU0 status register contains the state of the N, Z, C, V, and I, T and other
interrupt mode bit.
Its structure is shown below.</p>
<div class="figure align-center" id="llvmstructure-f3">
<img alt="_images/34.png" src="_images/34.png" />
<p class="caption">Figure 6: CPU0 status register</p>
</div>
<p>When CMP Ra, Rb instruction execution, the state flag will thus change.</p>
<p>If Ra&gt; Rb, then the setting state of N = 0, Z = 0.
If Ra &lt;Rb, it will set the state of N = 1, Z = 0.
If Ra = Rb, then the setting state of N = 0, Z = 1.</p>
<p>So conditional jump the JGT, JLT, JGE, JLE, JEQ, JNE instruction jumps N, Z
flag in the status register.</p>
</div>
<div class="section" id="the-execution-of-the-instruction-step">
<h3>The execution of the instruction step<a class="headerlink" href="#the-execution-of-the-instruction-step" title="Permalink to this headline">¶</a></h3>
<p>CPU0 has three stage pipeline: Instruction fetch, Decode and Execution.</p>
<ol class="arabic simple">
<li>Instruction fetch</li>
</ol>
<ul class="simple">
<li>Action 1. The instruction fetch: IR = [PC]</li>
<li>Action 2. Update program counter: PC = PC + 4</li>
</ul>
<ol class="arabic simple" start="2">
<li>Decode</li>
</ol>
<ul class="simple">
<li>Action 3. Decode: Control unit decodes IR, then set data flow switch
and ALU operation mode.</li>
</ul>
<ol class="arabic simple" start="3">
<li>Execute</li>
</ol>
<ul class="simple">
<li>Action 4. Execute: Data flow into ALU. After ALU done the operation,
the result stored back into destination register.</li>
</ul>
</div>
<div class="section" id="replace-ldi-instruction-by-addiu-instruction">
<h3>Replace ldi instruction by addiu instruction<a class="headerlink" href="#replace-ldi-instruction-by-addiu-instruction" title="Permalink to this headline">¶</a></h3>
<p>We have recognized the ldi instruction is a bad design and replace it with mips
instruction addiu.
The reason we replace ldi with addiu is that ldi use only one register even
though ldi is L type format and has two registers, as <a class="reference internal" href="#llvmstructure-f4"><em>Cpu0 ldi instruction</em></a>.
Mips addiu which allow programmer to do load constant to register like ldi,
and add constant to a register. So, it&#8217;s powerful and fully contains the ldi
ability.
These two instructions format as <a class="reference internal" href="#llvmstructure-f4"><em>Cpu0 ldi instruction</em></a> and <a class="reference internal" href="#llvmstructure-f5"><em>Mips addiu instruction format</em></a>.</p>
<div class="figure align-center" id="llvmstructure-f4">
<img alt="_images/43.png" src="_images/43.png" />
<p class="caption">Figure 7: Cpu0 ldi instruction</p>
</div>
<div class="figure align-center" id="llvmstructure-f5">
<img alt="_images/52.png" src="_images/52.png" />
<p class="caption">Figure 8: Mips addiu instruction format</p>
</div>
<p>From <a class="reference internal" href="#llvmstructure-f4"><em>Cpu0 ldi instruction</em></a> and <a class="reference internal" href="#llvmstructure-f5"><em>Mips addiu instruction format</em></a>, you can find ldi $Ra,
5 can be replaced by addiu $Ra, $zero, 5.
And more, addiu can do addiu $Ra, $Rb, 5 which add $Rb and 5 then save to $Ra,
but ldi cannot.
As a cpu design, it&#8217;s common to redesign CPU instruction when find a better
solution during design the compiler backend for that CPU.
So, we add addiu instruction to cpu0.
The cpu0 is my brother&#8217;s work, I will find time to talk with him.</p>
</div>
</div>
<div class="section" id="llvm-structure">
<h2>LLVM structure<a class="headerlink" href="#llvm-structure" title="Permalink to this headline">¶</a></h2>
<p>Following came from AOSA <a class="footnote-reference" href="#id12" id="id3">[3]</a>.</p>
<p>The most popular design for a traditional static compiler (like most C
compilers) is the three phase design whose major components are the front end,
the optimizer and the back end (<a class="reference internal" href="#llvmstructure-f6"><em>Tree major components of a Three Phase Compiler</em></a>).
The front end parses source code, checking it for errors, and builds a
language-specific Abstract Syntax Tree (AST) to represent the input code.
The AST is optionally converted to a new representation for optimization, and
the optimizer and back end are run on the code.</p>
<div class="figure align-center" id="llvmstructure-f6">
<img alt="_images/62.png" src="_images/62.png" />
<p class="caption">Figure 9: Tree major components of a Three Phase Compiler</p>
</div>
<p>The optimizer is responsible for doing a broad variety of transformations to
try to improve the code&#8217;s running time, such as eliminating redundant
computations, and is usually more or less independent of language and target.
The back end (also known as the code generator) then maps the code onto the
target instruction set.
In addition to making correct code, it is responsible for generating good code
that takes advantage of unusual features of the supported architecture.
Common parts of a compiler back end include instruction selection, register
allocation, and instruction scheduling.</p>
<p>This model applies equally well to interpreters and JIT compilers.
The Java Virtual Machine (JVM) is also an implementation of this model, which
uses Java bytecode as the interface between the front end and optimizer.</p>
<p>The most important win of this classical design comes when a compiler decides
to support multiple source languages or target architectures.
If the compiler uses a common code representation in its optimizer, then a
front end can be written for any language that can compile to it, and a back
end can be written for any target that can compile from it, as shown in
<a class="reference internal" href="#llvmstructure-f7"><em>Retargetablity</em></a>.</p>
<div class="figure align-center" id="llvmstructure-f7">
<img alt="_images/72.png" src="_images/72.png" />
<p class="caption">Figure 10: Retargetablity</p>
</div>
<p>With this design, porting the compiler to support a new source language (e.g.,
Algol or BASIC) requires implementing a new front end, but the existing
optimizer and back end can be reused.
If these parts weren&#8217;t separated, implementing a new source language would
require starting over from scratch, so supporting N targets and M source
languages would need N*M compilers.</p>
<p>Another advantage of the three-phase design (which follows directly from
retargetability) is that the compiler serves a broader set of programmers than
it would if it only supported one source language and one target.
For an open source project, this means that there is a larger community of
potential contributors to draw from, which naturally leads to more enhancements
and improvements to the compiler.
This is the reason why open source compilers that serve many communities (like
GCC) tend to generate better optimized machine code than narrower compilers
like FreePASCAL.
This isn&#8217;t the case for proprietary compilers, whose quality is directly
related to the project&#8217;s budget.
For example, the Intel ICC Compiler is widely known for the quality of code it
generates, even though it serves a narrow audience.</p>
<p>A final major win of the three-phase design is that the skills required to
implement a front end are different than those required for the optimizer and
back end.
Separating these makes it easier for a &#8220;front-end person&#8221; to enhance and
maintain their part of the compiler.
While this is a social issue, not a technical one, it matters a lot in
practice, particularly for open source projects that want to reduce the barrier
to contributing as much as possible.</p>
<p>The most important aspect of its design is the LLVM Intermediate Representation
(IR), which is the form it uses to represent code in the compiler.
LLVM IR is designed to host mid-level analyses and transformations that you
find in the optimizer section of a compiler.
It was designed with many specific goals in mind, including supporting
lightweight runtime optimizations, cross-function/interprocedural
optimizations, whole program analysis, and aggressive restructuring
transformations, etc.
The most important aspect of it, though, is that it is itself defined as a
first class language with well-defined semantics.
To make this concrete, here is a simple example of a .ll file:</p>
<div class="highlight-c++"><pre>define i32 @add1(i32 %a, i32 %b) {
entry:
  %tmp1 = add i32 %a, %b
  ret i32 %tmp1
}
define i32 @add2(i32 %a, i32 %b) {
entry:
  %tmp1 = icmp eq i32 %a, 0
  br i1 %tmp1, label %done, label %recurse
recurse:
  %tmp2 = sub i32 %a, 1
  %tmp3 = add i32 %b, 1
  %tmp4 = call i32 @add2(i32 %tmp2, i32 %tmp3)
  ret i32 %tmp4
done:
  ret i32 %b
}
This LLVM IR corresponds to this C code, which provides two different ways to
 add integers:
unsigned add1(unsigned a, unsigned b) {
  return a+b;
}
// Perhaps not the most efficient way to add two numbers.
unsigned add2(unsigned a, unsigned b) {
  if (a == 0) return b;
  return add2(a-1, b+1);
}
</pre>
</div>
<p>As you can see from this example, LLVM IR is a low-level RISC-like virtual
instruction set.
Like a real RISC instruction set, it supports linear sequences of simple
instructions like add, subtract, compare, and branch.
These instructions are in three address form, which means that they take some
number of inputs and produce a result in a different register.
LLVM IR supports labels and generally looks like a weird form of assembly
language.</p>
<p>Unlike most RISC instruction sets, LLVM is strongly typed with a simple type
system (e.g., i32 is a 32-bit integer, i32** is a pointer to pointer to 32-bit
integer) and some details of the machine are abstracted away.
For example, the calling convention is abstracted through call and ret
instructions and explicit arguments.
Another significant difference from machine code is that the LLVM IR doesn&#8217;t
use a fixed set of named registers, it uses an infinite set of temporaries
named with a % character.</p>
<p>Beyond being implemented as a language, LLVM IR is actually defined in three
isomorphic forms: the textual format above, an in-memory data structure
inspected and modified by optimizations themselves, and an efficient and dense
on-disk binary &#8220;bitcode&#8221; format.
The LLVM Project also provides tools to convert the on-disk format from text to
binary: llvm-as assembles the textual .ll file into a .bc file containing the
bitcode goop and llvm-dis turns a .bc file into a .ll file.</p>
<p>The intermediate representation of a compiler is interesting because it can be
a &#8220;perfect world&#8221; for the compiler optimizer: unlike the front end and back end
of the compiler, the optimizer isn&#8217;t constrained by either a specific source
language or a specific target machine.
On the other hand, it has to serve both well: it has to be designed to be easy
for a front end to generate and be expressive enough to allow important
optimizations to be performed for real targets.</p>
</div>
<div class="section" id="target-description-td">
<h2>Target Description td<a class="headerlink" href="#target-description-td" title="Permalink to this headline">¶</a></h2>
<p>The &#8220;mix and match&#8221; approach allows target authors to choose what makes sense
for their architecture and permits a large amount of code reuse across
different targets.
This brings up another challenge: each shared component needs to be able to
reason about target specific properties in a generic way.
For example, a shared register allocator needs to know the register file of
each target and the constraints that exist between instructions and their
register operands.
LLVM&#8217;s solution to this is for each target to provide a target description
in a declarative domain-specific language (a set of .td files) processed by the
tblgen tool.
The (simplified) build process for the x86 target is shown in
<a class="reference internal" href="#llvmstructure-f8"><em>Simplified x86 Target Definition</em></a>.</p>
<div class="figure align-center" id="llvmstructure-f8">
<img alt="_images/82.png" src="_images/82.png" />
<p class="caption">Figure 11: Simplified x86 Target Definition</p>
</div>
<p>The different subsystems supported by the .td files allow target authors to
build up the different pieces of their target.
For example, the x86 back end defines a register class that holds all of its
32-bit registers named &#8220;GR32&#8221; (in the .td files, target specific definitions
are all caps) like this:</p>
<div class="highlight-c++"><pre>def GR32 : RegisterClass&lt;[i32], 32,
  [EAX, ECX, EDX, ESI, EDI, EBX, EBP, ESP,
   R8D, R9D, R10D, R11D, R14D, R15D, R12D, R13D]&gt; { … }
</pre>
</div>
</div>
<div class="section" id="write-td-target-description">
<h2>Write td (Target Description)<a class="headerlink" href="#write-td-target-description" title="Permalink to this headline">¶</a></h2>
<p>The llvm using .td file (Target Description) to describe register and
instruction format.
After finish the .td files, llvm can generate C++ files (*.inc) by llvm-tblgen
tools.
The *.inc file is a text file (C++ file) with table driven in concept.
<a class="footnote-reference" href="#id13" id="id4">[4]</a> is the web site.</p>
<p>Every back end has a target td which define it&#8217;s own target information.
File td is like C++ in syntax. For example the Cpu0.td as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">/===--</span> <span class="n">Cpu0</span><span class="p">.</span><span class="n">td</span> <span class="o">-</span> <span class="n">Describe</span> <span class="n">the</span> <span class="n">Cpu0</span> <span class="n">Target</span> <span class="n">Machine</span> <span class="o">---------*-</span> <span class="n">tablegen</span> <span class="o">-*-===</span><span class="c1">//</span>
<span class="c1">// </span>
<span class="c1">//                     The LLVM Compiler Infrastructure </span>
<span class="c1">// </span>
<span class="c1">// This file is distributed under the University of Illinois Open Source </span>
<span class="c1">// License. See LICENSE.TXT for details. </span>
<span class="c1">// </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// This is the top level entry point for the Cpu0 target. </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Target-independent interfaces </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s">&quot;llvm/Target/Target.td&quot;</span> 
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Register File, Calling Conv, Instruction Descriptions </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">include</span> <span class="s">&quot;Cpu0RegisterInfo.td&quot;</span> 
<span class="n">include</span> <span class="s">&quot;Cpu0Schedule.td&quot;</span> 
<span class="n">include</span> <span class="s">&quot;Cpu0InstrInfo.td&quot;</span> 

<span class="n">def</span> <span class="n">Cpu0InstrInfo</span> <span class="o">:</span> <span class="n">InstrInfo</span><span class="p">;</span> 

<span class="n">def</span> <span class="n">Cpu0</span> <span class="o">:</span> <span class="n">Target</span> <span class="p">{</span> 
<span class="c1">// def Cpu0InstrInfo : InstrInfo as before. </span>
  <span class="n">let</span> <span class="n">InstructionSet</span> <span class="o">=</span> <span class="n">Cpu0InstrInfo</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>
</div>
<p>The registers td named Cpu0RegisterInfo.td included by Cpu0.td is defined as
follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  Cpu0RegisterInfo.td</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//  Declarations that describe the CPU0 register file </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// We have banks of 16 registers each. </span>
<span class="k">class</span> <span class="nc">Cpu0Reg</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">n</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="p">{</span> 
  <span class="n">field</span> <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">Num</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s">&quot;Cpu0&quot;</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="c1">// Cpu0 CPU Registers </span>
<span class="k">class</span> <span class="nc">Cpu0GPRReg</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">,</span> <span class="n">string</span> <span class="n">n</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">Cpu0Reg</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="p">{</span> 
  <span class="n">let</span> <span class="n">Num</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span> 
<span class="p">}</span> 
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//  Registers </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s">&quot;Cpu0&quot;</span> <span class="n">in</span> <span class="p">{</span> 
  <span class="c1">// General Purpose Registers </span>
  <span class="n">def</span> <span class="n">ZERO</span> <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ZERO&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">AT</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;AT&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">V0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">V1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">A0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">A1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&quot;5&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">T9</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">6</span><span class="p">,</span> <span class="s">&quot;6&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">S0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">7</span><span class="p">,</span> <span class="s">&quot;7&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">S1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;8&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">S2</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&quot;9&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">GP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&quot;GP&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">FP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">11</span><span class="p">,</span> <span class="s">&quot;FP&quot;</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">SW</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&quot;SW&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">SP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">13</span><span class="p">,</span> <span class="s">&quot;SP&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">LR</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">14</span><span class="p">,</span> <span class="s">&quot;LR&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
  <span class="n">def</span> <span class="n">PC</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">15</span><span class="p">,</span> <span class="s">&quot;PC&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 
<span class="c1">//  def MAR  : Cpu0GPRReg&lt; 16, &quot;MAR&quot;&gt;,  DwarfRegNum&lt;[16]&gt;; </span>
<span class="c1">//  def MDR  : Cpu0GPRReg&lt; 17, &quot;MDR&quot;&gt;,  DwarfRegNum&lt;[17]&gt;; </span>
<span class="p">}</span> 
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Register Classes </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="n">def</span> <span class="n">CPURegs</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> 
  <span class="c1">// Return Values and Arguments </span>
  <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> 
  <span class="c1">// Not preserved across procedure calls </span>
  <span class="n">T9</span><span class="p">,</span> 
  <span class="c1">// Callee save </span>
  <span class="n">S0</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> 
  <span class="c1">// Reserved </span>
  <span class="n">ZERO</span><span class="p">,</span> <span class="n">AT</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> <span class="n">SW</span><span class="p">,</span> <span class="n">SP</span><span class="p">,</span> <span class="n">LR</span><span class="p">,</span> <span class="n">PC</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
<p>In C++ the data layout is declared by class. Declaration tells the variable
layout; definition allocates memory for the variable.
For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>	<span class="c1">// declare Date</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">;</span>
<span class="p">};</span> 
<span class="n">Date</span> <span class="n">date</span><span class="p">;</span>	<span class="c1">// define(instance) date</span>
</pre></div>
</div>
<p>Just like C++ class, the keyword “class” is used for declaring data structure
layout.
<tt class="docutils literal"><span class="pre">Cpu0Reg&lt;string</span> <span class="pre">n&gt;</span></tt> declare a derived class from <tt class="docutils literal"><span class="pre">Register&lt;n&gt;</span></tt> which is
declared by llvm already, where n is the argument of type string.
In addition to inherited from all the fields of Register class, Cpu0Reg add a
new field &#8220;Num&#8221; of type 4 bits.
Namespace is same with  C++ namespace.
“Def” is used by define(instance) a concrete variable.</p>
<p>As above, we define a ZERO register which type is Cpu0GPRReg, it&#8217;s field Num
is 0 (4 bits) and field n is “ZERO” (declared in Register class).
Note the use of “let” expressions to override values that are initially defined
in a superclass. For example, let Namespace = “Cpu0” in class Cpu0Reg, will
override Namespace declared in Register class.
The Cpu0RegisterInfo.td also define that CPURegs is a variable for type of
RegisterClass, where the RegisterClass is a llvm built-in class.
The type of RegisterClass is a set/group of Register, so CPURegs variable is
defined with a set of Register.</p>
<p>The cpu0 instructions td is named to Cpu0InstrInfo.td which contents as follows,</p>
<div class="highlight-c++"><pre>/===- Cpu0InstrInfo.td - Target Description for Cpu0 Target -*- tablegen -*-=//
// 
//                     The LLVM Compiler Infrastructure 
// 
// This file is distributed under the University of Illinois Open Source 
// License. See LICENSE.TXT for details. 
// 
//===----------------------------------------------------------------------===//
// 
// This file contains the Cpu0 implementation of the TargetInstrInfo class. 
// 
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// Instruction format superclass 
//===----------------------------------------------------------------------===//
 include "Cpu0InstrFormats.td" 
//===----------------------------------------------------------------------===//
// Cpu0 profiles and nodes 
//===----------------------------------------------------------------------===//
def SDT_Cpu0Ret          : SDTypeProfile&lt;0, 1, [SDTCisInt&lt;0&gt;]&gt;; 
// Return 
def Cpu0Ret : SDNode&lt;"Cpu0ISD::Ret", SDT_Cpu0Ret, [SDNPHasChain, 
                     SDNPOptInGlue]&gt;; 
//===----------------------------------------------------------------------===//
// Cpu0 Operand, Complex Patterns and Transformations Definitions. 
//===----------------------------------------------------------------------===//
def simm16      : Operand&lt;i32&gt; { 
  let DecoderMethod= "DecodeSimm16"; 
} 
// Address operand 
def mem : Operand&lt;i32&gt; { 
  let PrintMethod = "printMemOperand"; 
  let MIOperandInfo = (ops CPURegs, simm16); 
  let EncoderMethod = "getMemEncoding"; 
} 
// Node immediate fits as 16-bit sign extended on target immediate. 
// e.g. addiu 
def immSExt16  : PatLeaf&lt;(imm), [{ return isInt&lt;16&gt;(N-&gt;getSExtValue()); }]&gt;; 

// Cpu0 Address Mode! SDNode frameindex could possibily be a match 
// since load and store instructions from stack used it. 
def addr : ComplexPattern&lt;iPTR, 2, "SelectAddr", [frameindex], [SDNPWantParent]&gt;
; 

//===----------------------------------------------------------------------===//
// Pattern fragment for load/store 
//===----------------------------------------------------------------------===//
class AlignedLoad&lt;PatFrag Node&gt; : 
  PatFrag&lt;(ops node:$ptr), (Node node:$ptr), [{ 
  LoadSDNode *LD = cast&lt;LoadSDNode&gt;(N); 
  return LD-&gt;getMemoryVT().getSizeInBits()/8 &lt;= LD-&gt;getAlignment(); 
}]&gt;; 
class AlignedStore&lt;PatFrag Node&gt; : 
  PatFrag&lt;(ops node:$val, node:$ptr), (Node node:$val, node:$ptr), [{ 
  StoreSDNode *SD = cast&lt;StoreSDNode&gt;(N); 
  return SD-&gt;getMemoryVT().getSizeInBits()/8 &lt;= SD-&gt;getAlignment(); 
}]&gt;; 
// Load/Store PatFrags. 
def load_a          : AlignedLoad&lt;load&gt;; 
def store_a         : AlignedStore&lt;store&gt;; 
//===----------------------------------------------------------------------===//
// Instructions specific format 
//===----------------------------------------------------------------------===//
// Arithmetic and logical instructions with 2 register operands. 
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode, 
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; : 
  FL&lt;op, (outs RC:$ra), (ins RC:$rb, Od:$imm16), 
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"), 
     [(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; { 
  let isReMaterializable = 1; 
} 

// Move immediate imm16 to register ra. 
class MoveImm&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode, 
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; : 
  FL&lt;op, (outs RC:$ra), (ins RC:$rb, Od:$imm16), 
     !strconcat(instr_asm, "\t$ra, $imm16"), 
     [(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; { 
  let rb = 0; 
  let isReMaterializable = 1; 
} 

class FMem&lt;bits&lt;8&gt; op, dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern, 
          InstrItinClass itin&gt;: FL&lt;op, outs, ins, asmstr, pattern, itin&gt; { 
  bits&lt;20&gt; addr; 
  let Inst{19-16} = addr{19-16}; 
  let Inst{15-0}  = addr{15-0}; 
  let DecoderMethod = "DecodeMem"; 
} 

// Memory Load/Store 
let canFoldAsLoad = 1 in 
class LoadM&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode, RegisterClass RC, 
            Operand MemOpnd, bit Pseudo&gt;: 
  FMem&lt;op, (outs RC:$ra), (ins MemOpnd:$addr), 
     !strconcat(instr_asm, "\t$ra, $addr"), 
     [(set RC:$ra, (OpNode addr:$addr))], IILoad&gt; { 
  let isPseudo = Pseudo; 
} 
class StoreM&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode, RegisterClass RC, 
             Operand MemOpnd, bit Pseudo&gt;: 
  FMem&lt;op, (outs), (ins RC:$ra, MemOpnd:$addr), 
     !strconcat(instr_asm, "\t$ra, $addr"), 
     [(OpNode RC:$ra, addr:$addr)], IIStore&gt; { 
  let isPseudo = Pseudo; 
} 
// 32-bit load. 
multiclass LoadM32&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode, 
                   bit Pseudo = 0&gt; { 
  def #NAME# : LoadM&lt;op, instr_asm, OpNode, CPURegs, mem, Pseudo&gt;; 
} 
// 32-bit store. 
multiclass StoreM32&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode, 
                    bit Pseudo = 0&gt; { 
  def #NAME# : StoreM&lt;op, instr_asm, OpNode, CPURegs, mem, Pseudo&gt;; 
} 
//===----------------------------------------------------------------------===//
// Instruction definition 
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// Cpu0I Instructions 
//===----------------------------------------------------------------------===//
/// Load and Store Instructions 
///  aligned 
defm LD      : LoadM32&lt;0x00,  "ld",  load_a&gt;; 
defm ST      : StoreM32&lt;0x01, "st",  store_a&gt;; 

/// Arithmetic Instructions (ALU Immediate)
//def LDI     : MoveImm&lt;0x08, "ldi", add, simm16, immSExt16, CPURegs&gt;;
// add defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1, 
    isBarrier=1, hasCtrlDep=1 in 
  def RET : FJ &lt;0x2C, (outs), (ins CPURegs:$target), 
                "ret\t$target", [(Cpu0Ret CPURegs:$target)], IIBranch&gt;; 

//===----------------------------------------------------------------------===//
//  Arbitrary patterns that map to one or more instructions 
//===----------------------------------------------------------------------===//
// Small immediates 

def : Pat&lt;(i32 immSExt16:$in), 
          (ADDiu ZERO, imm:$in)&gt;;
</pre>
</div>
<p>The Cpu0InstrFormats.td is included by Cpu0InstInfo.td as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstrFormats.td - Cpu0 Instruction Formats -----*- tablegen -*-===//</span>
<span class="c1">// </span>
<span class="c1">//                     The LLVM Compiler Infrastructure </span>
<span class="c1">// </span>
<span class="c1">// This file is distributed under the University of Illinois Open Source </span>
<span class="c1">// License. See LICENSE.TXT for details. </span>
<span class="c1">// </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//  Describe CPU0 instructions format </span>
<span class="c1">// </span>
<span class="c1">//  CPU INSTRUCTION FORMATS </span>
<span class="c1">// </span>
<span class="c1">//  opcode  - operation code. </span>
<span class="c1">//  ra      - dst reg, only used on 3 regs instr. </span>
<span class="c1">//  rb      - src reg. </span>
<span class="c1">//  rc      - src reg (on a 3 reg instr). </span>
<span class="c1">//  cx      - immediate </span>
<span class="c1">// </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">// Format specifies the encoding used by the instruction.  This is part of the </span>
<span class="c1">// ad-hoc solution used to emit machine instruction encodings by our machine </span>
<span class="c1">// code emitter. </span>
<span class="k">class</span> <span class="nc">Format</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">val</span><span class="o">&gt;</span> <span class="p">{</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">Value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="n">def</span> <span class="n">Pseudo</span>    <span class="o">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span> 
<span class="n">def</span> <span class="n">FrmA</span>      <span class="o">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span> 
<span class="n">def</span> <span class="n">FrmL</span>      <span class="o">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span> 
<span class="n">def</span> <span class="n">FrmJ</span>      <span class="o">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span> 
<span class="n">def</span> <span class="n">FrmFR</span>     <span class="o">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span> 
<span class="n">def</span> <span class="n">FrmFI</span>     <span class="o">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">;</span> 
<span class="n">def</span> <span class="n">FrmOther</span>  <span class="o">:</span> <span class="n">Format</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// Instruction w/ a custom format </span>

<span class="c1">// Generic Cpu0 Format </span>
<span class="k">class</span> <span class="nc">Cpu0Inst</span><span class="o">&lt;</span><span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span> 
               <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="p">,</span> <span class="n">Format</span> <span class="n">f</span><span class="o">&gt;:</span> <span class="n">Instruction</span> 
<span class="p">{</span> 
  <span class="n">field</span> <span class="n">bits</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">Inst</span><span class="p">;</span> 
  <span class="n">Format</span> <span class="n">Form</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s">&quot;Cpu0&quot;</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">Size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> 

  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

  <span class="c1">// Top 8 bits are the &#39;opcode&#39; field </span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">31</span><span class="o">-</span><span class="mi">24</span><span class="p">}</span> <span class="o">=</span> <span class="n">Opcode</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">OutOperandList</span> <span class="o">=</span> <span class="n">outs</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">InOperandList</span>  <span class="o">=</span> <span class="n">ins</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">AsmString</span>   <span class="o">=</span> <span class="n">asmstr</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">Pattern</span>     <span class="o">=</span> <span class="n">pattern</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">Itinerary</span>   <span class="o">=</span> <span class="n">itin</span><span class="p">;</span> 

  <span class="c1">// </span>
  <span class="c1">// Attributes specific to Cpu0 instructions... </span>
  <span class="c1">// </span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">FormBits</span> <span class="o">=</span> <span class="n">Form</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span> 

  <span class="c1">// TSFlags layout should be kept in sync with Cpu0InstrInfo.h. </span>
  <span class="n">let</span> <span class="n">TSFlags</span><span class="p">{</span><span class="mi">3</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>   <span class="o">=</span> <span class="n">FormBits</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">DecoderNamespace</span> <span class="o">=</span> <span class="s">&quot;Cpu0&quot;</span><span class="p">;</span> 

  <span class="n">field</span> <span class="n">bits</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">SoftFail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Format A instruction class in Cpu0 : &lt;|opcode|ra|rb|rc|cx|&gt; </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FA</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> 
         <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;:</span> 
      <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmA</span><span class="o">&gt;</span> 
<span class="p">{</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rc</span><span class="p">;</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">imm12</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">12</span><span class="p">}</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">11</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm12</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Format I instruction class in Cpu0 : &lt;|opcode|ra|rb|cx|&gt; </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FL</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span> 
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmL</span><span class="o">&gt;</span> 
<span class="p">{</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">imm16</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm16</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Format J instruction class in Cpu0 : &lt;|opcode|address|&gt; </span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FJ</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span> 
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmJ</span><span class="o">&gt;</span>
<span class="p">{</span> 
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">24</span><span class="o">&gt;</span> <span class="n">addr</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> 

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span> 
<span class="p">}</span> 
</pre></div>
</div>
<p>ADDiu is class ArithLogicI inherited from FL, can expand and get member value
as follows,</p>
<div class="highlight-c++"><pre>def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

/// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs RC:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
     [(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}

So,
op = 0x09
instr_asm = “addiu”
OpNode = add
Od = simm16
imm_type = immSExt16
RC = CPURegs
</pre>
</div>
<p>Expand with FL further,</p>
<div class="highlight-c++"><pre> :  FL&lt;op, (outs RC:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"), 
     [(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt;

class FL&lt;bits&lt;8&gt; op, dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern, 
         InstrItinClass itin&gt;: Cpu0Inst&lt;outs, ins, asmstr, pattern, itin, FrmL&gt;
{ 
  bits&lt;4&gt;  ra; 
  bits&lt;4&gt;  rb; 
  bits&lt;16&gt; imm16; 

  let Opcode = op; 

  let Inst{23-20} = ra; 
  let Inst{19-16} = rb; 
  let Inst{15-0}  = imm16; 
}

So,
op = 0x09
outs = CPURegs:$ra
ins = CPURegs:$rb,simm16:$imm16
asmstr = "addiu\t$ra, $rb, $imm16"
pattern = [(set CPURegs:$ra, (add RC:$rb, immSExt16:$imm16))]
itin = IIAlu

Members are,
ra = CPURegs:$ra
rb = CPURegs:$rb
imm16 = simm16:$imm16
Opcode = 0x09;
Inst{23-20} = CPURegs:$ra; 
Inst{19-16} = CPURegs:$rb; 
Inst{15-0}  = simm16:$imm16; 
</pre>
</div>
<p>Expand with Cpu0Inst further,</p>
<div class="highlight-c++"><pre>class FL&lt;bits&lt;8&gt; op, dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern, 
         InstrItinClass itin&gt;: Cpu0Inst&lt;outs, ins, asmstr, pattern, itin, FrmL&gt;

class Cpu0Inst&lt;dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern, 
               InstrItinClass itin, Format f&gt;: Instruction 
{ 
  field bits&lt;32&gt; Inst; 
  Format Form = f; 

  let Namespace = "Cpu0"; 

  let Size = 4; 

  bits&lt;8&gt; Opcode = 0; 

  // Top 8 bits are the 'opcode' field 
  let Inst{31-24} = Opcode; 

  let OutOperandList = outs; 
  let InOperandList  = ins; 

  let AsmString   = asmstr; 
  let Pattern     = pattern; 
  let Itinerary   = itin; 

  // 
  // Attributes specific to Cpu0 instructions... 
  // 
  bits&lt;4&gt; FormBits = Form.Value; 

  // TSFlags layout should be kept in sync with Cpu0InstrInfo.h. 
  let TSFlags{3-0}   = FormBits; 

  let DecoderNamespace = "Cpu0"; 

  field bits&lt;32&gt; SoftFail = 0; 
}

So,
outs = CPURegs:$ra
ins = CPURegs:$rb,simm16:$imm16
asmstr = "addiu\t$ra, $rb, $imm16"
pattern = [(set CPURegs:$ra, (add RC:$rb, immSExt16:$imm16))]
itin = IIAlu
f =  FrmL

Members are,
Inst{31-24} = 0x09; 
OutOperandList = CPURegs:$ra 
InOperandList  = CPURegs:$rb,simm16:$imm16
AsmString = "addiu\t$ra, $rb, $imm16"
Pattern = [(set CPURegs:$ra, (add RC:$rb, immSExt16:$imm16))]
Itinerary = IIAlu

Summary with all members are, 
// Inherited from parent like Instruction
Namespace = "Cpu0";
DecoderNamespace = "Cpu0";
Inst{31-24} = 0x08; 
Inst{23-20} = CPURegs:$ra; 
Inst{19-16} = CPURegs:$rb; 
Inst{15-0}  = simm16:$imm16; 
OutOperandList = CPURegs:$ra 
InOperandList  = CPURegs:$rb,simm16:$imm16
AsmString = "addiu\t$ra, $rb, $imm16"
Pattern = [(set CPURegs:$ra, (add RC:$rb, immSExt16:$imm16))]
Itinerary = IIAlu
// From Cpu0Inst
Opcode = 0x09;
// From FL
ra = CPURegs:$ra
rb = CPURegs:$rb
imm16 = simm16:$imm16
</pre>
</div>
<p>It&#8217;s a lousy process.
Similarly, LD and ST instruction definition can be expanded in this way.
Please notify the Pattern =
[(set CPURegs:$ra, (add RC:$rb, immSExt16:$imm16))] which include keyword
“add”.
We will use it in DAG transformations later.</p>
</div>
<div class="section" id="writing-configuration-files">
<h2>Writing configuration files<a class="headerlink" href="#writing-configuration-files" title="Permalink to this headline">¶</a></h2>
<p>You must have to add one LLVMBuild.txt under <tt class="docutils literal"><span class="pre">Target/Cpu0</span></tt> directory.
If you want to support cmake, then CMakeLists.txt needed to be added.</p>
<p>LLVMBuild.txt files are written in a simple variant of the INI or configuration
file format.
Comments are prefixed by <tt class="docutils literal"><span class="pre">#</span></tt> in both files.
We explain the setting for these 2 files in comments.
Please spend a little time to read it.</p>
<p>Both CMakeLists.txt and LLVMBuild.txt coexist in sub-directories
<tt class="docutils literal"><span class="pre">MCTargetDesc</span></tt> and <tt class="docutils literal"><span class="pre">TargetInfo</span></tt>.
Their contents indicate they will generate Cpu0Desc and Cpu0Info libraries.
After building, you will find three libraries: <tt class="docutils literal"><span class="pre">libLLVMCpu0CodeGen.a</span></tt>,
<tt class="docutils literal"><span class="pre">libLLVMCpu0Desc.a</span></tt> and <tt class="docutils literal"><span class="pre">libLLVMCpu0Info.a</span></tt> in lib/ of your build
directory.
For more details please see
&#8220;Building LLVM with CMake&#8221; <a class="footnote-reference" href="#id14" id="id5">[5]</a> and
&#8220;LLVMBuild Guide&#8221; <a class="footnote-reference" href="#id15" id="id6">[6]</a>.</p>
</div>
<div class="section" id="target-registration">
<h2>Target Registration<a class="headerlink" href="#target-registration" title="Permalink to this headline">¶</a></h2>
<p>You must also register your target with the TargetRegistry, which is what other
LLVM tools use to be able to lookup and use your target at runtime.
The TargetRegistry can be used directly, but for most targets there are helper
templates which should take care of the work for you.</p>
<p>All targets should declare a global Target object which is used to represent
the target during registration.
Then, in the target&#8217;s TargetInfo library, the target should define that object
and use the RegisterTarget template to register the target.
For example, the file TargetInfo/Cpu0TargetInfo.cpp register TheCpu0Target for
big endian and TheCpu0elTarget for little endian, as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// TargetInfo/Cpu0TargetInfo.cpp</span>
<span class="p">...</span>
<span class="n">Target</span> <span class="n">llvm</span><span class="o">::</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">TheCpu0elTarget</span><span class="p">;</span> 
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetInfo</span><span class="p">()</span> <span class="p">{</span> 
  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">,</span> 
        <span class="cm">/*HasJIT=*/</span><span class="kc">true</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="s">&quot;cpu0&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0&quot;</span><span class="p">);</span> 

  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="p">,</span> 
        <span class="cm">/*HasJIT=*/</span><span class="kc">true</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="s">&quot;cpu0el&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0el&quot;</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>
</div>
<p>Files Cpu0TargetMachine.cpp and MCTargetDesc/Cpu0MCTargetDesc.cpp just define
the empty initialize function since we register nothing in them for this moment.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.cpp - Define TargetMachine for Cpu0 -------------===//</span>
<span class="p">...</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0Target</span><span class="p">()</span> <span class="p">{</span> 
<span class="p">}</span> 
<span class="p">...</span>

<span class="c1">//===-- Cpu0MCTargetDesc.cpp - Cpu0 Target Descriptions -------------------===//</span>
<span class="p">...</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span> 
<span class="p">}</span>
</pre></div>
</div>
<p>Please see &#8220;Target Registration&#8221; <a class="footnote-reference" href="#id16" id="id7">[7]</a> for reference.</p>
</div>
<div class="section" id="build-libraries-and-td">
<h2>Build libraries and td<a class="headerlink" href="#build-libraries-and-td" title="Permalink to this headline">¶</a></h2>
<p>The llvm3.1 source code is put in /usr/local/llvm/3.1/src and have llvm3.1
release-build in /usr/local/llvm/3.1/configure_release_build.
About how to build llvm, please refer <a class="footnote-reference" href="#id17" id="id8">[8]</a>.
We made a copy from /usr/local/llvm/3.1/src to
/usr/local/llvm/3.1.test/cpu0/1/src for working with my Cpu0 target back end.
Sub-directories src is for source code and cmake_debug_build is for debug
build directory.</p>
<p>Except directory src/lib/Target/Cpu0, there are a couple of files modified to
support cpu0 new Target.
Please check files in src_files_modify/src/.
You can search cpu0 without case sensitive to find the modified files by
command,</p>
<div class="highlight-c++"><pre>[Gamma@localhost cmake_debug_build]$ grep -R -i "cpu0" ../src/ 
../src/CMakeLists.txt:  Cpu0 
../src/lib/Target/LLVMBuild.txt:subdirectories = ARM CellSPU CppBackend Hexagon 
MBlaze MSP430 Mips Cpu0 PTX PowerPC Sparc X86 XCore ../src/lib/MC/MCExpr.cpp:  
case VK_Cpu0_GPREL: return "GPREL"; 
...
../src/lib/MC/MCELFStreamer.cpp:    case MCSymbolRefExpr::VK_Cpu0_TLSGD: 
...
../src/lib/MC/MCDwarf.cpp:  // AT_language, a 4 byte value.  We use DW_LANG_Cpu0
_Assembler as the dwarf2 
../src/lib/MC/MCDwarf.cpp: // MCOS-&gt;EmitIntValue(dwarf::DW_LANG_Cpu0_Assembler, 
2); 
../src/lib/Support/Triple.cpp:  case cpu0:    return "cpu0";
 ...
../src/include/llvm/Support/ELF.h:  EM_LATTICEMICO32 = 138, // RISC processor fo
r Lattice CPU0 architecture
...
</pre>
</div>
<p>You can update your llvm working copy by,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cp</span> <span class="o">-</span><span class="n">rf</span> <span class="n">LLVMBackendTutorial</span><span class="o">/</span><span class="n">src_files_modified</span><span class="o">/</span><span class="n">src</span><span class="o">/*</span>   <span class="n">yourllvm</span><span class="o">/</span><span class="n">workingcopy</span><span class="o">/</span><span class="n">sourc</span>
<span class="n">edir</span><span class="o">/</span><span class="p">.</span>
</pre></div>
</div>
<p>Now, run the cmake and make command to build td (the following cmake command is
for my setting),</p>
<div class="highlight-c++"><pre>[Gamma@localhost cmake_debug_build]$ cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_
C_COMPILER=clang -DCMAKE_BUILD_TYPE=Debug  -G "Unix Makefiles" ../src/

-- Targeting Cpu0 
...
-- Targeting XCore 
-- Configuring done 
-- Generating done 
-- Build files have been written to: /usr/local/llvm/3.1.test/cpu0/1/cmake_debug
_build 

[Gamma@localhost cmake_debug_build]$ make 
...
[100%] Built target gtest_main
</pre>
</div>
<p>After build, you can type command llc –version to find the cpu0 backend,</p>
<div class="highlight-c++"><pre>[Gamma@localhost cmake_debug_build]$ /usr/local/llvm/3.1.test/cpu0/1/cmake_debug
_build/bin/llc --version 
LLVM (http://llvm.org/): 
  LLVM version 3.1svn 
  DEBUG build with assertions. 
  Built Sep 21 2012 (18:27:58). 
  Default target: x86_64-unknown-linux-gnu 
  Host CPU: penryn 

  Registered Targets: 
    arm      - ARM 
    cellspu  - STI CBEA Cell SPU [experimental] 
    cpp      - C++ backend 
    cpu0     - Cpu0 
    cpu0el   - Cpu0el 
...
</pre>
</div>
<p>The “llc -version” can display “cpu0” and “cpu0el” message, because the
following code from file TargetInfo/Cpu0TargetInfo.cpp what in
&#8220;section Target Registration&#8221; <a class="footnote-reference" href="#id18" id="id9">[9]</a> we made.
List them as follows again,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0TargetInfo.cpp</span>
<span class="n">Target</span> <span class="n">llvm</span><span class="o">::</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">TheCpu0elTarget</span><span class="p">;</span> 

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetInfo</span><span class="p">()</span> <span class="p">{</span> 
  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">,</span> 
        <span class="cm">/*HasJIT=*/</span><span class="kc">true</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="s">&quot;cpu0&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0&quot;</span><span class="p">);</span> 

  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="p">,</span> 
        <span class="cm">/*HasJIT=*/</span><span class="kc">true</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="s">&quot;cpu0el&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0el&quot;</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>
</div>
<p>Now try to do llc command to compile input file ch3.cpp as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch3.cpp</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> 
<span class="p">{</span> 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span> 
</pre></div>
</div>
<p>First step, compile it with clang and get output ch3.bc as follows,</p>
<div class="highlight-c++"><pre>[Gamma@localhost InputFiles]$ clang -c ch3.cpp -emit-llvm -o ch3.bc
</pre>
</div>
<p>Next step, transfer bitcode .bc to human readable text format as follows,</p>
<div class="highlight-c++"><pre>[Gamma@localhost InputFiles]$ llvm-dis ch3.bc -o ch3.ll 

// ch3.ll
; ModuleID = 'ch3.bc' 
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f3
2:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:6
4-S128" 
target triple = "x86_64-unknown-linux-gnu" 

define i32 @main() nounwind uwtable { 
  %1 = alloca i32, align 4 
  store i32 0, i32* %1 
  ret i32 0 
}
</pre>
</div>
<p>Now, compile ch3.bc into ch3.cpu0.s, we get the error message as follows,</p>
<div class="highlight-c++"><pre>[Gamma@localhost InputFiles]$ /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/
bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s 
llc: /usr/local/llvm/3.1.test/cpu0/1/src/tools/llc/llc.cpp:456: int main(int, ch
ar **): Assertion `target.get() &amp;&amp; "Could not allocate target machine!"' failed. 
Stack dump: 
0.	Program arguments: /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/bin/llc
 -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s 
Aborted (core dumped)
</pre>
</div>
<p>Currently we just define target td files (Cpu0.td, Cpu0RegisterInfo.td, ...).
According to LLVM structure, we need to define our target machine and include
those td related files.
The error message say we didn&#8217;t define our target machine.</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://ccckmit.wikidot.com/ocs:cpu0">http://ccckmit.wikidot.com/ocs:cpu0</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://translate.google.com.tw/translate?js=n&amp;prev=_t&amp;hl=zh-TW&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=zh-CN&amp;tl=en&amp;u=http://ccckmit.wikidot.com/ocs:cpu0">http://translate.google.com.tw/translate?js=n&amp;prev=_t&amp;hl=zh-TW&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=zh-CN&amp;tl=en&amp;u=http://ccckmit.wikidot.com/ocs:cpu0</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/TableGenFundamentals.html">http://llvm.org/docs/TableGenFundamentals.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://llvm.org/docs/CMake.html">http://llvm.org/docs/CMake.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><a class="reference external" href="http://llvm.org/docs/LLVMBuild.html">http://llvm.org/docs/LLVMBuild.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration">http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td><a class="reference external" href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td><a class="reference external" href="http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Cpu0 Instruction and LLVM Target Description</a><ul>
<li><a class="reference internal" href="#cpu0-processor-architecture">CPU0 processor architecture</a><ul>
<li><a class="reference internal" href="#brief-introduction">Brief introduction</a></li>
<li><a class="reference internal" href="#instruction-set-for-cpu0">Instruction Set for CPU0</a></li>
<li><a class="reference internal" href="#status-register">Status register</a></li>
<li><a class="reference internal" href="#the-execution-of-the-instruction-step">The execution of the instruction step</a></li>
<li><a class="reference internal" href="#replace-ldi-instruction-by-addiu-instruction">Replace ldi instruction by addiu instruction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-structure">LLVM structure</a></li>
<li><a class="reference internal" href="#target-description-td">Target Description td</a></li>
<li><a class="reference internal" href="#write-td-target-description">Write td (Target Description)</a></li>
<li><a class="reference internal" href="#writing-configuration-files">Writing configuration files</a></li>
<li><a class="reference internal" href="#target-registration">Target Registration</a></li>
<li><a class="reference internal" href="#build-libraries-and-td">Build libraries and td</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="install.html"
                        title="previous chapter">Getting Started: Installing LLVM and the Cpu0 example code</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="backendstructure.html"
                        title="next chapter">LLVM Backend Structure</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/llvmstructure.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="backendstructure.html" title="LLVM Backend Structure"
             >next</a> |</li>
        <li class="right" >
          <a href="install.html" title="Getting Started: Installing LLVM and the Cpu0 example code"
             >previous</a> |</li>
        <li><a href="index.html">Write An LLVM Backend Tutorial For Cpu0</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>