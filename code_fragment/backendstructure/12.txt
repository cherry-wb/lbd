    // In this stage, reorder the instructions sequence for optimization in
    // instructions cycle or in register pressure.
    st i32 %a, i16* %b, i16 5 ; st %a to *(%b+5)
    st %b, i32* %c, i16 0
    %d = ld i32* %c

    // Transfer above instructions order as follows. In RISC architecture like
    // Mips, since the "ld %c" depends on previous instruction "st %c", it must
    // wait more than 1 cycles. Therefore, the ld cannot follow st immediately.
=>  st %b, i32* %c, i16 0
    st i32 %a, i16* %b,  i16 5
    %d = ld i32* %c, i16 0

    // If without reordering instructions, a instruction nop which does nothing
    // must be inserted as a bubble, contribute one instruction cycle more than
    // optimization.
    // Actually, Mips is scheduled with hardware dynamically and will insert nop
    // between st and ld instructions if compiler didn't insert nop.
    st i32 %a, i16* %b,  i16 5
    st %b, i32* %c, i16 0
=>  nop
    %d = ld i32* %c, i16 0

    // Minimum register pressure
    //
    // Suppose %c is alive after this basic block (meaning %c will be
    // used after this basic block), %a and %b are not dead after this
    // one. The following non-reordering version need 3 registers at least.
    %a = add i32 1, i32 0
    %b = add i32 2, i32 0
    st %a,  i32* %c, 1
    st %b,  i32* %c, 2

    // The reordering version need 2 registers only (by allocate %a and %b in the same
    // register)
=>  %a = add i32 1, i32 0
    st %a,  i32* %c, 1
    %b = add i32 2, i32 0
    st %b,  i32* %c, 2
