

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LLVM Backend Structure &mdash; Write An LLVM Backend Tutorial For Cpu0</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Write An LLVM Backend Tutorial For Cpu0" href="index.html" />
    <link rel="next" title="Adding arithmetic and local pointer support" href="otherinst.html" />
    <link rel="prev" title="Introduce Cpu0 and LLVM" href="llvmstructure.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="otherinst.html" title="Adding arithmetic and local pointer support"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="llvmstructure.html" title="Introduce Cpu0 and LLVM"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Write An LLVM Backend Tutorial For Cpu0</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="llvm-backend-structure">
<span id="backend-structure"></span><h1>LLVM Backend Structure<a class="headerlink" href="#llvm-backend-structure" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduces the LLVM backend class inheritance tree and class members
first. Next, we follow the LLVM backend structure and add class implementation one
by one in each section. In this chapter, we need some compiler knowledge, like
<a class="reference external" href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/Instruction_selection">instruction
selection</a>, we will introduce
them when needed. At the end of this chapter, we will have a backend being able
to compile LLVM IR into cpu0 assembly code.</p>
<p>The code added in this chapter are common in every LLVM backend, the only difference
are their name. In fact, since Cpu0 is similar to Mips we copy most of the code from
the Mips backend. In this chapter, we will focus on the relationship between classes
involved in writing a LLVM backend. Once knowing the overall structure, you can
quickly create a simple backend from scratch.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Following content came from &#8220;Design and Implementation of a TriCore Backend for the LLVM Compiler Framework&#8221; <a class="footnote-reference" href="#id19" id="id1">[6]</a> Chapter 4. I already got author&#8217;s approve on the Chinese translation work. :-)</p>
</div>
<p>As mentioned in Chapter 2, LLVM provides developers with an extensive generic frame
work for code generation. It prescribes a fixed directory layout and class hierarchy
template. Each backend is located in its own subdirectory within lib/Target, where
most of the code to be implemented goes. Apart from this, only a handful of the original
files in the LLVM source tree have to be modified in order to integrate the new backend
with the existing LLVM codebase.</p>
<p>如同第二章所提到，LLVM 提供開發者一套相當通用的框架用來開發後端。LLVM 提供一個
固定的目錄布局，和類別階層。每一個後端都位在各自位於 <tt class="docutils literal"><span class="pre">lib/Target</span></tt> 的子目錄，
大部分的實作代碼都在該子目錄底下。除此之外，只有少部分 LLVM 代碼需要修改以將
新增的後端整合進 LLVM 代碼庫。</p>
<p>The target code generator is divided into several components, each of which is discussed
in a separate section. For a better overview, each section contains a list of the source
files that comprise the respective component</p>
<p>目標後端被分為數個元件，底下各節將分別加以討論。為了加強讀者整體印象，各節會列出
相應的檔案。</p>
<p>The given class hierarchy specifies a number of abstract base classes with virtual
functions and requires the backend developer to implement subclasses for each of them.
Most of these classes do not provide any immediate functionality for code generation, but
merely give selected information about the characteristics and properties of the target
machine. This makes it possible to keep the bulk of the actual algorithms and procedures
fully target-independent by accessing all the required target-specific information through
the specified interfaces.</p>
<p>LLVM 的類別階層指定數個抽象基礎類別，其中定義數個虛擬函式。後端開發者必須實做前述
抽象類別的子類別，並依據需要實做虛擬函式。大部分的類別僅提供目標的各項資訊和特性，
與後端代碼生成並不相關。這使得演算法和其它程序與底層目標無關，僅透過指定的界面存取
目標資訊。</p>
</div>
<div class="section" id="code-generation-process">
<h2>Code Generation Process<a class="headerlink" href="#code-generation-process" title="Permalink to this headline">¶</a></h2>
<p>為了瞭解 LLVM 後端的結構，先理解 LLVM  後端是如何生成目標代碼是必要的。
將 LLVM IR 轉成目標代碼，後端需要經過數個步驟 <a class="footnote-reference" href="#id14" id="id2">[1]</a> 。</p>
<div class="section" id="id3">
<h3>Instruction Selection<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>目標代碼生成的第一步，是將 LLVM IR 轉成一組 <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> ，
這是一個有向無環圖，其中每一個節點代表一條 LLVM 指令。任兩條指令之間的 definition-use
關係由一條從 using node 指向 defining node 的邊描述，邊上伴隨受影響變數的型別其資訊。
如果指令之間有 control flow dependency ，會以額外的邊加以表示。由於目標並不保證支持
所有 LLVM 提供的型別和操作，前述的 DAG 必須先加以合法化，也就是要先將其轉成目標支持
的型別和操作。合法化的 DAG 再交由 instruction selector 以樣式匹配的方式，創建以目標
指令為內容的 DAG 節點。對於每一個匹配到的 LLVM DAG 節點，相應目標指令的 DAG 節點
會被建立。instruction selector 的輸入和輸出都是 DAG，只是其內容由 LLVM 指令轉成目標指令。</p>
</div>
<div class="section" id="scheduling-and-formation">
<h3>Scheduling and Formation<a class="headerlink" href="#scheduling-and-formation" title="Permalink to this headline">¶</a></h3>
<p>前述由目標指令所構成的的 DAG 將會在此階段被解構成目標指令序列 (list)。每一個函式以
一個 <a class="reference external" href="http://llvm.org/docs/doxygen/html/classllvm_1_1MachineFunction.html">MachineFunction</a> 加以表示，其中包含 <a class="reference external" href="http://llvm.org/docs/doxygen/html/classllvm_1_1MachineBasicBlock.html">MachineBlock</a> 串列。 <a class="reference external" href="http://llvm.org/docs/doxygen/html/classllvm_1_1MachineBasicBlock.html">MachineBlock</a>
中又包含數條 <a class="reference external" href="http://llvm.org/docs/doxygen/html/classllvm_1_1MachineInstr.html">MachineInstr</a> 。Scheduler 必須決定以何種順序將目標指令寫出，這會受
到許多因素影響，例如: 最小 register pressure，亦即減少因暫存器數量不足，而需要將
暫存器內容暫時搬移至內存的次數。</p>
<p>此時，目標指令序列仍舊保持 SSA 形式，它並非合法的匯編。除了少數例外 (像是將返回值
搬移至 ABI 所規定的暫存器)，所有的指令仍舊操作 LLVM 提供的無限量虛擬暫存器，且所有
存取棧的指令均是存取虛擬的棧空間，而非真正的偏移量。</p>
</div>
<div class="section" id="ssa-based-machine-code-optimization">
<h3>SSA-based Machine Code Optimization<a class="headerlink" href="#ssa-based-machine-code-optimization" title="Permalink to this headline">¶</a></h3>
<p>在分配物理暫存器之前，後端有機會針對保有 SSA 形式的目標指令序列進行 SSA 相關的優化。</p>
</div>
<div class="section" id="register-allocation">
<h3>Register Allocation<a class="headerlink" href="#register-allocation" title="Permalink to this headline">¶</a></h3>
<p>虛擬暫存器將在此階段被消除，改以物理暫存器對應之。LLVM 暫存器分配器將會為每一個虛擬
暫存器分配一個物理暫存器。如果虛擬暫存器數量超過實際可用的物理暫存器，暫存器分配器
會產生 spill code 將某個物理暫存器搬移至內存以供使用。因為暫存器有可能重疊，例如:
<tt class="docutils literal"><span class="pre">%e2</span></tt> 暫存器分別由 <tt class="docutils literal"><span class="pre">%d3</span></tt> 和 <tt class="docutils literal"><span class="pre">%d2</span></tt> 構成其上下半部，暫存器分配器必須考慮到這種
情況。虛擬暫存器的消除同時伴隨著 SSA 形式的解構。為建立 SSA 形式所插入的 phi 指令
將被 copy 指令所取代。</p>
</div>
<div class="section" id="prologue-epilogue-code-insertion">
<h3>Prologue/Epilogue Code Insertion<a class="headerlink" href="#prologue-epilogue-code-insertion" title="Permalink to this headline">¶</a></h3>
<p>在暫存器分配器運行之後，我們可以計算每一個函式將會需要多少棧空間。進而在函式的出入口
寫入相對應的 prologue 和 epilogue。之前存取虛擬棧空間的指令，現在可以存取到相對應
棧頂 (sp) 或是棧底 (fp) 指針的偏移量。</p>
</div>
<div class="section" id="late-machine-code-optimizations">
<h3>Late Machine Code Optimizations<a class="headerlink" href="#late-machine-code-optimizations" title="Permalink to this headline">¶</a></h3>
<p>在將目標指令寫出之前，可以做窺孔優化 (peephole optimization)，對目標指令做細部調整。</p>
</div>
<div class="section" id="code-emission">
<h3>Code Emission<a class="headerlink" href="#code-emission" title="Permalink to this headline">¶</a></h3>
<p>最後，完整的目標代碼被寫出。對於靜態編譯，其結果可以是匯編文本; 對於 JIT 編譯，目標指
令的編碼將被寫入內存。</p>
</div>
</div>
<div class="section" id="general-target-information">
<h2>General Target Information<a class="headerlink" href="#general-target-information" title="Permalink to this headline">¶</a></h2>
<p>每一個 LLVM 後端都必須要提供一個介面供上層原件調用。後端必須實現 <a class="reference external" href="http://llvm.org/docs/doxygen/html/classllvm_1_1LLVMTargetMachine.html">LLVMTargetMachine</a>
的子類，提供目標平台必要資訊，並向 LLVM 代碼生成器註冊。</p>
<div class="section" id="target-machine-characteristics">
<h3>Target Machine Characteristics<a class="headerlink" href="#target-machine-characteristics" title="Permalink to this headline">¶</a></h3>
<p>類別 <tt class="docutils literal"><span class="pre">XXTargetMachine</span></tt> 扮演著中心的角色，它是目標後端和 LLVM 其它原件之間的界面。
它創建並擁有數個物件描述目標平台資訊，LLVM 代碼生成器透過 <tt class="docutils literal"><span class="pre">XXTargetMachine</span></tt> 取
得相應資訊。</p>
<ul class="simple">
<li><a class="reference external" href="http://llvm.org/docs/doxygen/html/classllvm_1_1DataLayout.html">DataLayout</a> 描述目標的資料佈局，如: 大小端，指針寬度和內存對齊。</li>
<li><a class="reference external" href="http://llvm.org/docs/doxygen/html/TargetFrameLowering_8h.html">TargetFrameLowering</a> 描述目標棧框佈局。它指明棧生長方向、棧上空間的對齊要求和本地變數應從棧底何處偏移量開始存取。</li>
<li>其它類別諸如: <a class="reference external" href="http://llvm.org/docs/doxygen/html/TargetInstrInfo_8h_source.html">TargetInstrInfo</a> 、 <a class="reference external" href="http://llvm.org/docs/doxygen/html/TargetLowering_8h.html">TargetLowering</a> 和  <a class="reference external" href="http://llvm.org/docs/doxygen/html/TargetRegisterInfo_8h_source.html">TargetRegisterInfo</a> 。底下各節會分別加以描述。</li>
</ul>
</div>
<div class="section" id="subtarget-information">
<h3>Subtarget Information<a class="headerlink" href="#subtarget-information" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="build-example-code">
<h2>Build Example Code<a class="headerlink" href="#build-example-code" title="Permalink to this headline">¶</a></h2>
<p>We build our example code first, then add components step by step.</p>
<ol class="arabic">
<li><p class="first">Prepare the source code.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">cd </span>cpu0
<span class="nv">$ </span>mkdir -p 3/src; <span class="nb">cd </span>3/src
<span class="nv">$ </span>cp -rf ../../2/src/* .
<span class="nv">$ </span>cp -rf <span class="nv">$Example_SRC</span>/3/1/Cpu0/ lib/Target/
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Build</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>mkdir debug; <span class="nb">cd </span>debug
<span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -DCMAKE_C_COMPILER<span class="o">=</span>clang <span class="se">\</span>
  -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;Mips;Cpu0&quot;</span> <span class="se">\</span>
  -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug -G <span class="s2">&quot;Unix Makefiles&quot;</span> ../src/
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
<div class="section" id="step-1-add-xxtargetmachine">
<h3>Step 1. Add XXTargetMachine<a class="headerlink" href="#step-1-add-xxtargetmachine" title="Permalink to this headline">¶</a></h3>
<p>The role of TargetMachine in the LLVM backend structure is shown in <a class="pageref" href="#target-machine">figure  1</a>. <a class="reference external" href="http://llvm.org/docs/CommandGuide/llc.html">llc</a> is LLVM static compiler.
When you invoke <tt class="docutils literal"><span class="pre">llc</span></tt> command with option <tt class="docutils literal"><span class="pre">-march=XX</span></tt>, it will trigger the
corresponding callback functions.</p>
<div class="align-center figure" id="target-machine">
<img alt="_images/target_machine.png" src="_images/target_machine.png" />
<p class="caption">Figure 1: The role of TargetMachine</p>
</div>
<p><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine">Target Machine</a> is
a base class for targets implemented with the LLVM target-independent code generator.
You should define a <tt class="docutils literal"><span class="pre">XXTargetMachine</span></tt> class which inherit class <tt class="docutils literal"><span class="pre">LLVMTargetMachine</span></tt>,
where XX is your target name. In our tutorial we name it as <tt class="docutils literal"><span class="pre">Cpu0TargetMachine</span></tt>.
Class Cpu0TargetMachine has data members which define target layout, instruction
information, frame/stack ...etc. The Cpu0TargetMachine contents as follows,</p>
<div class="highlight-c++" id="cpu0-target-machine"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.h - Define TargetMachine for Cpu0 -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of TargetMachine.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETMACHINE_H</span>
<span class="cp">#define CPU0TARGETMACHINE_H</span>

<span class="cp">#include &quot;Cpu0FrameLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0ISelLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0SelectionDAGInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetData.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">formatted_raw_ostream</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LLVMTargetMachine</span> <span class="p">{</span>
    <span class="n">Cpu0Subtarget</span>       <span class="n">Subtarget</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">TargetData</span>    <span class="n">DataLayout</span><span class="p">;</span> <span class="c1">// Calculates type size &amp; alignment</span>
    <span class="n">Cpu0InstrInfo</span>       <span class="n">InstrInfo</span><span class="p">;</span>	<span class="c1">//- Instructions</span>
    <span class="n">Cpu0FrameLowering</span>   <span class="n">FrameLowering</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0TargetLowering</span>  <span class="n">TLInfo</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0SelectionDAGInfo</span> <span class="n">TSInfo</span><span class="p">;</span>	<span class="c1">//- Map .bc DAG to backend DAG</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                      <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0InstrInfo</span>   <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">FrameLowering</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0Subtarget</span>   <span class="o">*</span><span class="n">getSubtargetImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetData</span>      <span class="o">*</span><span class="n">getTargetData</span><span class="p">()</span>    <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">DataLayout</span><span class="p">;}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetLowering</span> <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TLInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0SelectionDAGInfo</span><span class="o">*</span> <span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TSInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Pass Pipeline Configuration</span>
    <span class="k">virtual</span> <span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">);</span>
  <span class="p">};</span>

<span class="c1">/// Cpu0ebTargetMachine - Cpu032 big endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0ebTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">/// Cpu0elTargetMachine - Cpu032 little endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0elTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>Due to the OO design of LLVM, most member functions are already implemented by
base classes. We only need to override some member functions for our target machine.</p>
<p>After writing up our target description files, <tt class="docutils literal"><span class="pre">llvm-tblgen</span></tt> generates C++ files
included by others. Take <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.td</span></tt> as an example, <tt class="docutils literal"><span class="pre">llvm-tblgen</span></tt> generates
<tt class="docutils literal"><span class="pre">Cpu0GenInstrInfo.inc</span></tt> from <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.td</span></tt>. Then <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.h</span></tt> defines
<tt class="docutils literal"><span class="pre">GET_INSTRINFO_HEADER</span></tt> marco so that it can get code it needs from <tt class="docutils literal"><span class="pre">Cpu0GenInstrInfo.inc</span></tt>
Below is the code fragment from Cpu0GenInstrInfo.inc.</p>
<p>Code between <tt class="docutils literal"><span class="pre">#if</span> <span class="pre">def</span>&nbsp; <span class="pre">GET_INSTRINFO_HEADER</span></tt> and <tt class="docutils literal"><span class="pre">#endif</span> <span class="pre">//</span> <span class="pre">GET_INSTRINFO_HEADER</span></tt>
will be extracted by <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.h.</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td </span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER </span>
<span class="cp">#undef GET_INSTRINFO_HEADER </span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span> 
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span> 
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
<span class="p">};</span> 
<span class="p">}</span> <span class="c1">// End llvm namespace </span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>

<span class="c1">//- Cpu0InstrInfo.h extracts above code by defining GET_INSTRINFO_HEADER</span>
<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Reference Write An LLVM Backend web site <a class="footnote-reference" href="#id15" id="id5">[2]</a>.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>cp -rf <span class="nv">$Example_SRC</span>/3/1/Cpu0 lib/Target
</pre></div>
</div>
</div></blockquote>
<p>We add the following files in this section, and we have to modify CMakefile.txt
to include thhose new added C++ files.</p>
<ol class="arabic simple">
<li>Cpu0TargetMachine.[h,cpp]</li>
<li>Cpu0Subtarget.[h,cpp]</li>
<li>Cpu0InstrInfo.[h,cpp]</li>
<li>Cpu0FrameLowering.[h,cpp]</li>
<li>Cpu0TargetLowering.[h,cpp]</li>
<li>Cpu0SelectionDAGInfo.[h,cpp]</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp"># CMakeLists.txt </span>
<span class="p">...</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span> 
  <span class="n">Cpu0ISelLowering</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0InstrInfo</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0FrameLowering</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0Subtarget</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0TargetMachine</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0SelectionDAGInfo</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="p">)</span>
</pre></div>
</div>
<p>Please follow commands below to build example code for this section.</p>
<ol class="arabic">
<li><p class="first">Prepare the source code.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">cd </span>cpu0
<span class="nv">$ </span>mkdir -p 3/1/src; <span class="nb">cd </span>3/1/src
<span class="nv">$ </span>cp -rf ../../../2/src/* .
<span class="nv">$ </span>cp -rf <span class="nv">$Example_SRC</span>/3/1/Cpu0/ lib/Target/
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Build</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>mkdir debug; <span class="nb">cd </span>debug
<span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -DCMAKE_C_COMPILER<span class="o">=</span>clang <span class="se">\</span>
  -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;Mips;Cpu0&quot;</span> <span class="se">\</span>
  -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug -G <span class="s2">&quot;Unix Makefiles&quot;</span> ../src/
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="step-2-add-registerinfo">
<h3>Step 2. Add RegisterInfo<a class="headerlink" href="#step-2-add-registerinfo" title="Permalink to this headline">¶</a></h3>
<p>class <cite>Cpu0InstrInfo</cite> has a data member of class <cite>Cpu0RegisterInfo</cite>.
This section adds class <cite>Cpu0RegisterInfo</cite>, then includes it in <cite>Cpu0InstrInfo.h</cite>
and <cite>Cpu0TargetMachine.h</cite>. Finally, we modify CMakefile.txt to add our new added
file <cite>Cpu0RegisterInfo.cpp</cite>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0InstrInfo.h</span>
<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span> 
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span> 
  <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="n">RI</span><span class="p">;</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span> 

  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 

<span class="k">public</span><span class="o">:</span> 
<span class="p">};</span>

<span class="c1">//- Cpu0InstrInfo.cpp</span>
<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span> 
  <span class="o">:</span> 
    <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span> 
    <span class="n">RI</span><span class="p">(</span><span class="o">*</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtargetImpl</span><span class="p">(),</span> <span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{}</span> 

<span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="n">RI</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="c1">//  Cpu0TargetMachine.h</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">*</span><span class="n">getRegisterInfo</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>
    <span class="p">}</span>

<span class="cp"># CMakeLists.txt </span>
<span class="p">...</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span> 
  <span class="p">...</span>
  <span class="n">Cpu0RegisterInfo</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>Now, let&#8217;s replace 3/1/Cpu0 with 3/2/Cpu0 of adding register class definition
and rebuild.</p>
<ol class="arabic">
<li><p class="first">Prepare the source code.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">cd </span>cpu0/3
<span class="nv">$ </span>mkdir -p 2/src; <span class="nb">cd </span>2/src
<span class="nv">$ </span>cp -rf ../../1/src/* .
<span class="nv">$ </span>cp -rf <span class="nv">$Example_SRC</span>/3/2/Cpu0/ lib/Target/
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Build</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>mkdir debug; <span class="nb">cd </span>debug
<span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -DCMAKE_C_COMPILER<span class="o">=</span>clang <span class="se">\</span>
  -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;Mips;Cpu0&quot;</span> <span class="se">\</span>
  -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug -G <span class="s2">&quot;Unix Makefiles&quot;</span> ../src/
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
<p>Now, let&#8217;s run <tt class="docutils literal"><span class="pre">llc</span></tt> to compile a LLVM bitcode to see what happen.</p>
<ol class="arabic">
<li><p class="first">Prepare LLVM bitcode.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>clang -c example/input/ch3.cpp -emit-llvm -o ch3.bc
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Compile</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o ch3.cpu0.s
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
<div class="highlight-bash"><pre>llc: /cpu0/3/2/src/lib/CodeGen/LLVMTargetMachine.cpp:78: llvm::LLVMTargetMachine::LLVMTargetMachine(const llvm::Target &amp;, llvm::StringRef, llvm::StringRef, llvm::StringRef, llvm::TargetOptions, Reloc::Model, CodeModel::Model, CodeGenOpt::Level): Assertion `AsmInfo &amp;&amp; "MCAsmInfo not initialized." "Make sure you include the correct TargetSelect.h" "and that InitializeAllTargetMCs() is being invoked!"' failed.
Stack dump:
0.      Program arguments: ./bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s
Aborted</pre>
</div>
<p>Look into the assertion in above error message, it tell us that we don&#8217;t have
a ASMPrinter for our target to print assembly. We will add it in next section.</p>
</div>
<div class="section" id="step-3-add-asmprinter">
<h3>Step 3. Add AsmPrinter<a class="headerlink" href="#step-3-add-asmprinter" title="Permalink to this headline">¶</a></h3>
<p>First, wee modify <tt class="docutils literal"><span class="pre">Cpu0.td</span></tt> to add support for ASMPrinter. LLVM now has a newer
ASMPrinter called MCAsmWriter, we explictly say we will support MCAsmWriter.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Proc</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">Name</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">SubtargetFeature</span><span class="o">&gt;</span> <span class="n">Features</span><span class="o">&gt;</span> 
 <span class="o">:</span> <span class="n">Processor</span><span class="o">&lt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">Cpu0GenericItineraries</span><span class="p">,</span> <span class="n">Features</span><span class="o">&gt;</span><span class="p">;</span> 

<span class="n">def</span> <span class="o">:</span> <span class="n">Proc</span><span class="o">&lt;</span><span class="s">&quot;cpu032&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">FeatureCpu032</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 

<span class="n">def</span> <span class="n">Cpu0AsmWriter</span> <span class="o">:</span> <span class="n">AsmWriter</span> <span class="p">{</span> 
  <span class="n">string</span> <span class="n">AsmWriterClassName</span>  <span class="o">=</span> <span class="s">&quot;InstPrinter&quot;</span><span class="p">;</span> 
  <span class="n">bit</span> <span class="n">isMCAsmWriter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="n">def</span> <span class="n">Cpu0</span> <span class="o">:</span> <span class="n">Target</span> <span class="p">{</span> 
  <span class="n">let</span> <span class="n">InstructionSet</span> <span class="o">=</span> <span class="n">Cpu0InstrInfo</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">AssemblyWriters</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmWriter</span><span class="p">];</span> 
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">llvm-tblgen</span></tt> will generate <tt class="docutils literal"><span class="pre">Cpu0GenAsmWrite.inc</span></tt> included by <tt class="docutils literal"><span class="pre">Cpu0InstPrinter.cpp</span></tt>
which will be added soon. <tt class="docutils literal"><span class="pre">Cpu0GenAsmWrite.inc</span></tt> implements two member functions:
<tt class="docutils literal"><span class="pre">printInstruction</span></tt> and <tt class="docutils literal"><span class="pre">getRegisterName</span></tt> for class <tt class="docutils literal"><span class="pre">Cpu0InstPrinter</span></tt>.
Both of them are auto-generated from target description files we added before,
i.e., <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.td</span></tt> and <tt class="docutils literal"><span class="pre">Cpu0RegisterInfo.td</span></tt>. The last thing we have to
do is adding class <tt class="docutils literal"><span class="pre">Cpu0InstPrinter</span></tt>, then include <tt class="docutils literal"><span class="pre">Cpu0GenAsmWrite.inc</span></tt> in it.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//-  Cpu0InstPrinter.cpp</span>
<span class="cp">#include &quot;Cpu0GenAsmWriter.inc&quot; </span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printRegName</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RegNo</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> 
<span class="c1">//- getRegisterName(RegNo) defined in Cpu0GenAsmWriter.inc which came from</span>
<span class="c1">//-  Cpu0.td indicate. </span>
  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;$&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">RegNo</span><span class="p">)).</span><span class="n">lower</span><span class="p">();</span> 
<span class="p">}</span> 

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printInst</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> 
                                <span class="n">StringRef</span> <span class="n">Annot</span><span class="p">)</span> <span class="p">{</span> 
<span class="c1">//- printInstruction(MI, O) defined in Cpu0GenAsmWriter.inc which came from</span>
<span class="c1">//-  Cpu0.td indicate. </span>
  <span class="n">printInstruction</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span> 
  <span class="n">printAnnotation</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">Annot</span><span class="p">);</span> 
<span class="p">}</span> 
</pre></div>
</div>
<p>Next, add files below into new subdirectory <tt class="docutils literal"><span class="pre">MCTargetDesc</span></tt>.</p>
<ol class="arabic simple">
<li>Cpu0AsmPrinter.[h,cpp]</li>
<li>Cpu0MCInstLower.[h,cpp]</li>
<li>Cpu0BaseInfo.[h,cpp]</li>
<li>Cpu0FixupKinds.[h,cpp]</li>
<li>Cpu0MCAsmInfo.[h,cpp]</li>
</ol>
<p>We register our target MCAsmInfo and InstPrinter in <tt class="docutils literal"><span class="pre">Cpu0MCTargetDesc.cpp</span></tt>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//-  Cpu0MCTargetDesc.cpp</span>
<span class="k">static</span> <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">createCpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">MAI</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">);</span>

  <span class="n">MachineLocation</span> <span class="n">Dst</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">);</span>
  <span class="n">MachineLocation</span> <span class="n">Src</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">addInitialFrameState</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Dst</span><span class="p">,</span> <span class="n">Src</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MAI</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCInstPrinter</span> <span class="o">*</span><span class="n">createCpu0MCInstPrinter</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">SyntaxVariant</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCAsmInfo</span> <span class="o">&amp;</span><span class="n">MAI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MII</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0InstPrinter</span><span class="p">(</span><span class="n">MAI</span><span class="p">,</span> <span class="n">MII</span><span class="p">,</span> <span class="n">MRI</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Register the MC asm info.</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>

  <span class="c1">// Register the MCInstPrinter.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we register AsmPrinter in <tt class="docutils literal"><span class="pre">Cpu0AsmPrinter.cpp</span></tt>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0AsmPrinter.cpp</span>

<span class="c1">// Force static initialization.</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0AsmPrinter</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This sections adds two subdirectories: <tt class="docutils literal"><span class="pre">InstPrinter</span></tt> and <tt class="docutils literal"><span class="pre">MCTargetDesc</span></tt>.
You have to modify top-level LLVMBuild.txt and CMakefile.txt accordingly,
and add LLVMBuild.txt and CMakefile.txt into those subdirectories also.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//-  top-level LLVMBuild.txt</span>

<span class="p">[</span><span class="n">common</span><span class="p">]</span> 
<span class="n">subdirectories</span> <span class="o">=</span> <span class="n">InstPrinter</span> <span class="n">MCTargetDesc</span> <span class="n">TargetInfo</span> 

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span> 
<span class="p">...</span>
<span class="cp"># Please enable asmprinter</span>
<span class="n">has_asmprinter</span> <span class="o">=</span> <span class="mi">1</span> 
<span class="p">...</span>

<span class="p">[</span><span class="n">component_1</span><span class="p">]</span> 
<span class="cp"># Add AsmPrinter Cpu0AsmPrinter</span>
<span class="n">required_libraries</span> <span class="o">=</span> <span class="n">AsmPrinter</span> <span class="n">CodeGen</span> <span class="n">Core</span> <span class="n">MC</span> <span class="n">Cpu0AsmPrinter</span> <span class="n">Cpu0Desc</span> <span class="n">Cpu0Info</span>
</pre></div>
</div>
<p>O.K., let&#8217;s build example code, then run <tt class="docutils literal"><span class="pre">llc</span></tt> as before. You will see
error below:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>./bin/llc -march<span class="o">=</span>cpu0 ../../2/debug/ch3.bc
./bin/llc: target does not support generation of this file <span class="nb">type</span>!
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">llc</span></tt> fails to compile LLVM IR into target machine code since we don&#8217;t
implement class <tt class="docutils literal"><span class="pre">Cpu0DAGToDAGISel</span></tt> yet. Before moving on, we will introduce
LLVM code generation sequence, DAG, and instruction selection in next three
sections.</p>
</div>
</div>
<div class="section" id="llvm-code-generation-sequence">
<h2>LLVM Code Generation Sequence<a class="headerlink" href="#llvm-code-generation-sequence" title="Permalink to this headline">¶</a></h2>
<p>Following content came from
&#8220;Design and Implementation of a TriCore Backend for the LLVM Compiler Framework&#8221;
<a class="footnote-reference" href="#id19" id="id6">[6]</a> section 4.2 Code Generation Process.</p>
<p><a class="pageref" href="#code-generation-sequence">figure  2</a>
gives an overview of LLVM code generation sequence.</p>
<div class="align-center figure" id="code-generation-sequence">
<img alt="_images/code_generation_sequence.png" src="_images/code_generation_sequence.png" />
<p class="caption">Figure 2: LLVM code generation sequence</p>
</div>
<p>LLVM IR is a Static Single Assignment (SSA) <a class="footnote-reference" href="#id16" id="id7">[3]</a> based representation.
LLVM provides infinite virtual registers which can hold value of primitive
type (integral, floating point, or pointer).
So, every operand can save in different virtual register in LLVM SSA
representation.
Comment is prefixed with <tt class="docutils literal"><span class="pre">;</span></tt> in LLVM representation.</p>
<p>Following is a LLVM IR example.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">store</span> <span class="n">i32</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>  <span class="p">;</span> <span class="n">store</span> <span class="n">i32</span> <span class="n">type</span> <span class="n">of</span> <span class="mi">0</span> <span class="n">to</span> <span class="k">virtual</span> <span class="k">register</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span> <span class="n">is</span>
                      <span class="p">;</span>  <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span> <span class="p">;</span> <span class="n">store</span> <span class="o">%</span><span class="n">b</span> <span class="n">contents</span> <span class="n">to</span> <span class="o">%</span><span class="n">c</span> <span class="n">point</span> <span class="n">to</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="n">isi32</span> <span class="n">type</span> <span class="k">virtual</span>
                      <span class="p">;</span>  <span class="k">register</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span> <span class="n">is</span> <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span><span class="p">.</span>
<span class="o">%</span><span class="n">a1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>    <span class="p">;</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">value</span> <span class="n">where</span> <span class="o">%</span><span class="n">a</span> <span class="n">point</span> <span class="n">to</span> <span class="n">and</span> <span class="n">assign</span> <span class="n">the</span>
                      <span class="p">;</span>  <span class="n">memory</span> <span class="n">value</span> <span class="n">to</span> <span class="o">%</span><span class="n">a1</span>
<span class="o">%</span><span class="n">a3</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a2</span><span class="p">,</span> <span class="mi">1</span>  <span class="p">;</span> <span class="n">add</span> <span class="o">%</span><span class="n">a2</span> <span class="n">and</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">save</span> <span class="n">to</span> <span class="o">%</span><span class="n">a3</span>
</pre></div>
</div>
<p>We explain the code generation process as below.
If you don&#8217;t feel comfortable, please check tricore_llvm.pdf section 4.2 first.
You can  read “The LLVM Target-Independent Code Generator” from <a class="footnote-reference" href="#id17" id="id8">[4]</a>
and “LLVM Language Reference Manual” from <a class="footnote-reference" href="#id18" id="id9">[5]</a>
before go ahead, but we think read section
4.2 of tricore_llvm.pdf is enough.
We suggest you read the web site documents as above only when you are still not
quite understand, even though you have read this section and next 2 sections
article for DAG and Instruction Selection.</p>
<p>&#8220;Design and Implementation of a TriCore Backend for the LLVM Compiler Framework&#8221;
<a class="footnote-reference" href="#id19" id="id10">[6]</a> section 4.2.</p>
<ol class="arabic">
<li><p class="first">Instruction Selection</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// In this stage, transfer the llvm opcode into machine opcode, but the operand</span>
    <span class="c1">// still is llvm virtual operand.</span>
    <span class="n">store</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span> <span class="c1">// store 0 of i16 type to where virtual register %a</span>
                         <span class="c1">// point to</span>

<span class="o">=&gt;</span>  <span class="n">addiu</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Scheduling and Formation</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// In this stage, reorder the instructions sequence for optimization in</span>
    <span class="c1">// instructions cycle or in register pressure.</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">5</span> <span class="p">;</span> <span class="n">st</span> <span class="o">%</span><span class="n">a</span> <span class="n">to</span> <span class="o">*</span><span class="p">(</span><span class="o">%</span><span class="n">b</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span>

    <span class="c1">// Transfer above instructions order as follows. In RISC architecture like</span>
    <span class="c1">// Mips, since the &quot;ld %c&quot; depends on previous instruction &quot;st %c&quot;, it must</span>
    <span class="c1">// wait more than 1 cycles. Therefore, the ld cannot follow st immediately.</span>
<span class="o">=&gt;</span>  <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>

    <span class="c1">// If without reordering instructions, a instruction nop which does nothing</span>
    <span class="c1">// must be inserted as a bubble, contribute one instruction cycle more than</span>
    <span class="c1">// optimization.</span>
    <span class="c1">// Actually, Mips is scheduled with hardware dynamically and will insert nop</span>
    <span class="c1">// between st and ld instructions if compiler didn&#39;t insert nop.</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
<span class="o">=&gt;</span>  <span class="n">nop</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>

    <span class="c1">// Minimum register pressure</span>
    <span class="c1">//</span>
    <span class="c1">// Suppose %c is alive after this basic block (meaning %c will be</span>
    <span class="c1">// used after this basic block), %a and %b are not dead after this</span>
    <span class="c1">// one. The following non-reordering version need 3 registers at least.</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>

    <span class="c1">// The reordering version need 2 registers only (by allocate %a and %b in the same</span>
    <span class="c1">// register)</span>
<span class="o">=&gt;</span>  <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">SSA-based Machine Code Optimization</p>
<blockquote>
<div><p>For example, common expression remove, shown in next section DAG.</p>
</div></blockquote>
</li>
<li><p class="first">Register Allocation</p>
<blockquote>
<div><p>Allocate real register for virtual register.</p>
</div></blockquote>
</li>
<li><p class="first">Prologue/Epilogue Code Insertion</p>
<blockquote>
<div><p>Explain in section Add Prologue/Epilogue functions</p>
</div></blockquote>
</li>
<li><p class="first">Late Machine Code Optimizations</p>
<blockquote>
<div><p>Any &#8220;last-minute&#8221; peephole optimizations of the final machine code can
be applied during this phase. For example, replace &#8220;x = x * 2&#8221; by
&#8220;x = x &lt; 1&#8221; for integer operand.</p>
</div></blockquote>
</li>
<li><p class="first">Code Emission</p>
<blockquote>
<div><p>Finally, the completed machine code is emitted. For static compilation,
the end result is an assembly code file; for JIT compilation, the opcodes
of the machine instructions are written into memory.</p>
</div></blockquote>
</li>
</ol>
<div class="section" id="dag-directed-acyclic-graph">
<h3>DAG (Directed Acyclic Graph)<a class="headerlink" href="#dag-directed-acyclic-graph" title="Permalink to this headline">¶</a></h3>
<p>Many important techniques for local optimization begin by transforming a basic
block into DAG. For example, the basic block code and it&#8217;s corresponding DAG as
<a class="reference internal" href="#backendstructure-f6"><em>DAG example</em></a>.</p>
<div class="figure align-center" id="backendstructure-f6">
<img alt="_images/61.png" src="_images/61.png" />
<p class="caption">Figure 3: DAG example</p>
</div>
<p>If b is not live on exit from the block, then we can do common expression
remove to get the following code.</p>
<div class="highlight-c++"><pre>a = b + c
d = a – d
c = d + c
</pre>
</div>
<p>As you can imagine, the common expression remove can apply in IR or machine
code.</p>
<p>DAG like a tree which opcode is the node and operand (register and
const/immediate/offset) is leaf.
It can also be represented by list as prefix order in tree.
For example, (+ b, c), (+ b, 1) is IR DAG representation.</p>
</div>
<div class="section" id="id11">
<h3>Instruction Selection<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>In the compiler backend, we need to translate compiler intermediate representation
, i.e., IR code into machine code at instruction selection stage <a class="footnote-reference" href="#id20" id="id12">[7]</a>.</p>
<p><a class="pageref" href="#ir-and-machine-code">figure  4</a> shows a simple example to illustrate the
before and after instruction selection.</p>
<div class="figure align-center" id="ir-and-machine-code">
<img alt="_images/ir_and_machine_code.png" src="_images/ir_and_machine_code.png" />
<p class="caption">Figure 4: IR and it&#8217;s corresponding machine instruction</p>
</div>
<p>For machine instruction selection, the better solution is represent IR and
machine instruction by DAG.
In <a class="pageref" href="#instruction-tree-patterns">figure  5</a>, we skip the register leaf.
The rj + rk is IR DAG representation (for symbol notation, not llvm SSA form).
ADD is machine instruction.</p>
<div class="figure align-center" id="instruction-tree-patterns">
<img alt="_images/instruction_tree_patterns.png" src="_images/instruction_tree_patterns.png" />
<p class="caption">Figure 5: Instruction DAG representation</p>
</div>
<p>The IR DAG and machine instruction DAG can also represented as list.
For example, (+ ri, rj), (- ri, 1) are lists for IR DAG; (ADD ri, rj),
(SUBI ri, 1) are lists for machine instruction DAG.</p>
<p>Now, let&#8217;s recall the ADDiu instruction defined on Cpu0InstrInfo.td in the
previous chapter.
And It will expand to the following Pattern as mentioned in section Write td
(Target Description) of the previous chapter as follows,</p>
<div class="highlight-c++"><pre>def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

Pattern = [(set CPURegs:$ra, (add RC:$rb, immSExt16:$imm16))]
</pre>
</div>
<p>This pattern meaning the IR DAG node <strong>add</strong> can translate into machine
instruction DAG node ADDiu by pattern match mechanism.
Similarly, the machine instruction DAG node LD and ST can be got from IR DAG
node <strong>load</strong> and <strong>store</strong>.</p>
<p>Some cpu/fpu (floating point processor) has multiply-and-add floating point
instruction, fmadd.
It can be represented by DAG list (fadd (fmul ra, rc), rb).
For this implementation, we can assign fmadd DAG pattern to instruction td as
follows,</p>
<div class="highlight-c++"><pre>def FMADDS : AForm_1&lt;59, 29,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
                    "fmadds $FRT, $FRA, $FRC, $FRB",
                    [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                                           F4RC:$FRB))]&gt;;
</pre>
</div>
<p>Similar with ADDiu, [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
F4RC:$FRB))] is the pattern which include node <strong>fmul</strong> and node <strong>fadd</strong>.</p>
<p>Now, for the following basic block notation IR and llvm SSA IR code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">...</span>

<span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">fmul</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span>
<span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fadd</span> <span class="o">%</span><span class="n">d</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The llvm SelectionDAG Optimization Phase (is part of Instruction Selection
Process) prefered to translate this 2 IR DAG node (fmul %a, %b) (fadd %d, %c)
into one machine instruction DAG node (<strong>fmadd</strong> %a, %c, %b), than translate
them into 2 machine instruction nodes <strong>fmul</strong> and <strong>fadd</strong>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fmadd</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>As you can see, the IR notation representation is easier to read then llvm SSA
IR form.
So, we  use the notation form in this book sometimes.</p>
<p>For the following basic block code,</p>
<div class="highlight-c++"><pre>a = b + c		// in notation IR form
d = a – d
%e = fmadd %a, %c, %b	// in llvm SSA IR form
</pre>
</div>
<p>We can apply <em class="xref std std-ref">backendstructure_f7</em> Instruction tree pattern to get the
following machine code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">load</span>	<span class="n">rb</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span> <span class="c1">// assume b allocate in sp+8, sp is stack point register</span>
<span class="n">load</span>	<span class="n">rc</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span>
<span class="n">add</span>	<span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">load</span>	<span class="n">rd</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">24</span><span class="p">);</span>
<span class="n">sub</span>	<span class="n">rd</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">fmadd</span>	<span class="n">re</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rb</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="step-4-add-cpu0dagtodagisel">
<h3>Step 4. Add Cpu0DAGToDAGISel<a class="headerlink" href="#step-4-add-cpu0dagtodagisel" title="Permalink to this headline">¶</a></h3>
<p>The IR DAG to machine instruction DAG transformation is introduced in the
previous section.
Now, let&#8217;s check what IR DAG node the file ch3.bc has. List ch3.ll as follows,</p>
<div class="highlight-c++"><pre>// ch3.ll
define i32 @main() nounwind uwtable { 
%1 = alloca i32, align 4 
store i32 0, i32* %1 
ret i32 0 
} 
</pre>
</div>
<p>As above, ch3.ll use the IR DAG node <strong>store</strong>, <strong>ret</strong>. Actually, it also use
<strong>add</strong> for sp (stack point) register adjust.
So, the definitions in Cpu0InstInfo.td as follows is enough.
IR DAG is defined in file  include/llvm/Target/TargetSelectionDAG.td.</p>
<div class="highlight-c++"><pre>/// Load and Store Instructions 
///  aligned 
defm LD      : LoadM32&lt;0x00,  "ld",  load_a&gt;; 
defm ST      : StoreM32&lt;0x01, "st",  store_a&gt;; 

/// Arithmetic Instructions (ALU Immediate)
//def LDI     : MoveImm&lt;0x08, "ldi", add, simm16, immSExt16, CPURegs&gt;;
// add defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1, 
    isBarrier=1, hasCtrlDep=1 in 
  def RET : FJ &lt;0x2C, (outs), (ins CPURegs:$target), 
                "ret\t$target", [(Cpu0Ret CPURegs:$target)], IIBranch&gt;;
</pre>
</div>
<p>Add  class Cpu0DAGToDAGISel (Cpu0ISelDAGToDAG.cpp) to CMakeLists.txt, and add
following fragment to Cpu0TargetMachine.cpp,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  Cpu0TargetMachine.cpp</span>
<span class="p">...</span>
<span class="c1">// Install an instruction selector pass using</span>
<span class="c1">// the ISelDag to gen Cpu0 code.</span>
<span class="kt">bool</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addInstSelector</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">PM</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">getCpu0TargetMachine</span><span class="p">()));</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//  Cpu0ISelDAGToDAG.cpp</span>
<span class="c1">/// createCpu0ISelDag - This pass converts a legalized DAG into a </span>
<span class="c1">/// CPU0-specific DAG, ready for instruction scheduling. </span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0DAGToDAGISel</span><span class="p">(</span><span class="n">TM</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>
</div>
<p>This version adding the following code in Cpu0InstInfo.cpp to enable debug
information which called by llvm at proper time.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0InstInfo.cpp</span>
<span class="p">...</span>
<span class="n">MachineInstr</span><span class="o">*</span>
<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">emitFrameIndexDebugValue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIx</span><span class="p">,</span>
                                        <span class="n">uint64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">MDNode</span> <span class="o">*</span><span class="n">MDPtr</span><span class="p">,</span>
                                        <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">DBG_VALUE</span><span class="p">))</span>
    <span class="p">.</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FrameIx</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">).</span><span class="n">addMetadata</span><span class="p">(</span><span class="n">MDPtr</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&amp;*</span><span class="n">MIB</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Build 3/4, run it, we find the error message in 3/3 is gone. The new error
message for 3/4 as follows,</p>
<div class="highlight-c++"><pre>[Gamma@localhost InputFiles]$ /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/
bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s 
Target didn't implement TargetInstrInfo::storeRegToStackSlot! 
UNREACHABLE executed at /usr/local/llvm/3.1.test/cpu0/1/src/include/llvm/Target/
TargetInstrInfo.h:390! 
Stack dump: 
0.	Program arguments: /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/bin/llc
 -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s 
1.	Running pass 'Function Pass Manager' on module 'ch3.bc'. 
2.	Running pass 'Prologue/Epilogue Insertion &amp; Frame Finalization' on function 
'@main' 
Aborted (core dumped) 
</pre>
</div>
</div>
<div class="section" id="step-5-add-prologue-epilogue">
<h3>Step 5. Add Prologue/Epilogue<a class="headerlink" href="#step-5-add-prologue-epilogue" title="Permalink to this headline">¶</a></h3>
<p>Following came from
&#8220;Design and Implementation of a TriCore Backend for the LLVM Compiler Framework&#8221;
<a class="footnote-reference" href="#id18" id="id13">[5]</a> section 4.4.2.</p>
<p>For some target architectures, some aspects of the target architecture’s
register set are dependent upon variable factors and have to be determined at
runtime.
As a consequence, they cannot be generated statically from a TableGen
description – although that would be possible for the bulk of them in the case
of the TriCore backend.
Among them are the following points:</p>
<ul class="simple">
<li>Callee-saved registers. Normally, the ABI specifies a set of registers that a function must save on entry and restore on return if their contents are possibly modified during execution.</li>
<li>Reserved registers. Although the set of unavailable registers is already defined in the TableGen file, TriCoreRegisterInfo contains a method that marks all non-allocatable register numbers in a bit vector.</li>
</ul>
<p>The following methods are implemented:</p>
<ul class="simple">
<li>emitPrologue() inserts prologue code at the beginning of a function. Thanks to TriCore’s context model, this is a trivial task as it is not required to save any registers manually. The only thing that has to be done is reserving space for the function’s stack frame by decrementing the stack pointer. In addition, if the function needs a frame pointer, the frame register %a14 is set to the old value of the stack pointer beforehand.</li>
<li>emitEpilogue() is intended to emit instructions to destroy the stack frame and restore all previously saved registers before returning from a function. However, as %a10 (stack pointer), %a11 (return address), and %a14 (frame pointer, if any) are all part of the upper context, no epilogue code is needed at all. All cleanup operations are performed implicitly by the ret instruction.</li>
<li>eliminateFrameIndex() is called for each instruction that references a word of data in a stack slot. All previous passes of the code generator have been addressing stack slots through an abstract frame index and an immediate offset. The purpose of this function is to translate such a reference into a register–offset pair. Depending on whether the machine function that contains the instruction has a fixed or a variable stack frame, either the stack pointer %a10 or the frame pointer %a14 is used as the base register. The offset is computed accordingly. Figure 3.9 demonstrates for both cases how a stack slot is addressed.</li>
</ul>
<p>If the addressing mode of the affected instruction cannot handle the address because the offset is too large (the offset field has 10 bits for the BO addressing mode and 16 bits for the BOL mode), a sequence of instructions is emitted that explicitly computes the effective address. Interim results are put into an unused address register. If none is available, an already occupied address register is scavenged. For this purpose, LLVM’s framework offers a class named RegScavenger that takes care of all the details.</p>
<div class="figure align-center" id="backendstructure-f9">
<img alt="_images/91.png" src="_images/91.png" />
<p class="caption">Figure 6: Addressing of a variable a located on the stack. If the stack frame has a variable size, slot must be addressed relative to the frame pointer</p>
</div>
<p>We will explain the Prologue and Epilogue further by example code.
So for the following llvm IR code, Cpu0 back end will emit the corresponding
machine instructions as follows,</p>
<div class="highlight-c++"><pre>define i32 @main() nounwind uwtable { 
  %1 = alloca i32, align 4 
  store i32 0, i32* %1 
  ret i32 0 
}

	.section .mdebug.abi32
	.previous
	.file	"ch3.bc"
	.text
	.globl	main
	.align	2
	.type	main,@function
	.ent	main                    # @main
main:
	.frame	$sp,8,$lr
	.mask 	0x00000000,0
	.set	noreorder
	.set	nomacro
# BB#0:                                 # %entry
	addiu	$sp, $sp, -8
	addiu	$2, $zero, 0
	st	$2, 4($sp)
	addiu	$sp, $sp, 8
	ret	$lr
	.set	macro
	.set	reorder
	.end	main
$tmp1:
	.size	main, ($tmp1)-main
</pre>
</div>
<p>LLVM get the stack size by parsing IR and counting how many virtual registers
is assigned to local variables. After that, it call emitPrologue().
This function will emit machine instructions to adjust sp (stack pointer
register) for local variables since we don&#8217;t use fp (frame pointer register).
For our example, it will emit the instructions,</p>
<div class="highlight-c++"><pre>addiu	$sp, $sp, -8
</pre>
</div>
<p>The  emitEpilogue will emit “addiu  $sp, $sp, 8”, 8 is the stack size.</p>
<p>Since Instruction Selection and Register Allocation occurs before
Prologue/Epilogue Code Insertion, eliminateFrameIndex() is called after machine
instruction and real register allocated.
It translate the frame index of local variable (%1 and %2 in the following
example) into stack offset according the frame index order upward (stack grow
up downward from high address to low address, 0($sp) is the top, 52($sp) is the
bottom) as follows,</p>
<div class="highlight-c++"><pre>define i32 @main() nounwind uwtable { 
       %1 = alloca i32, align 4 
       %2 = alloca i32, align 4 
      ...
      store i32 0, i32* %1
      store i32 5, i32* %2, align 4 
      ...
      ret i32 0 

=&gt; # BB#0: 
	addiu	$sp, $sp, -56 
$tmp1: 
	addiu	$3, $zero, 0 
	st	$3, 52($sp)   // %1 is the first frame index local variable, so allocate
                      // in 52($sp)
	addiu	$2, $zero, 5 
	st	$2, 48($sp)   // %2 is the second frame index local variable, so 
                      // allocate in 48($sp)
    ...
    ret	$lr
</pre>
</div>
<p>After add these Prologue and Epilogue functions, and build with 3/5/Cpu0.
Now we are ready to compile our example code ch3.bc into cpu0 assembly code.
Following is the command and output file ch3.cpu0.s,</p>
<div class="highlight-c++"><pre>[Gamma@localhost InputFiles]$ /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/
bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s 
[Gamma@localhost InputFiles]$ cat ch3.cpu0.s 
	.section .mdebug.abi32
	.previous
	.file	"ch3.bc"
	.text
	.globl	main
	.align	2
	.type	main,@function
	.ent	main                    # @main
main:
	.frame	$sp,8,$lr
	.mask 	0x00000000,0
	.set	noreorder
	.set	nomacro
# BB#0:                                 # %entry
	addiu	$sp, $sp, -8
	addiu	$2, $zero, 0
	st	$2, 4($sp)
	addiu	$sp, $sp, 8
	ret	$lr
	.set	macro
	.set	reorder
	.end	main
$tmp1:
	.size	main, ($tmp1)-main
</pre>
</div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>We have finished a simple assembler for cpu0 which only support <strong>addiu</strong>,
<strong>st</strong> and <strong>ret</strong> 3 instructions.</p>
<p>We are satisfied with this result.
But you may think “After so many codes we program, and just get the 3
instructions”.
The point is we have created a frame work for cpu0 target machine (please
look back the llvm back end structure class inherit tree early in this
chapter).
Until now, we have around 3050 lines of source code with comments which include
files *.cpp, *.h, *.td, CMakeLists.txt and LLVMBuild.txt.
It can be counted by command <tt class="docutils literal"><span class="pre">wc</span> <span class="pre">`find</span> <span class="pre">dir</span> <span class="pre">-name</span> <span class="pre">*.cpp`</span></tt> for files *.cpp,
*.h, *.td, *.txt.
LLVM front end tutorial have 700 lines of source code without comments totally.
Don&#8217;t feel down with this result.
In reality, write a back end is warm up slowly but run fast.
Clang has over 500,000 lines of source code with comments in clang/lib
directory which include C++ and Obj C support.
Mips back end has only 15,000 lines with comments.
Even the complicate X86 CPU which CISC outside and RISC inside (micro
instruction), has only 45,000 lines with comments.
In next chapter, we will show you that add a new instruction support is as easy
as 123.</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine">http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[6]</a></td><td><a class="reference external" href="http://www.opus.ub.uni-erlangen.de/opus/volltexte/2010/1659/pdf/tricore_llvm.pdf">http://www.opus.ub.uni-erlangen.de/opus/volltexte/2010/1659/pdf/tricore_llvm.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[7]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Instruction_selection">http://en.wikipedia.org/wiki/Instruction_selection</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">LLVM Backend Structure</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#code-generation-process">Code Generation Process</a><ul>
<li><a class="reference internal" href="#id3">Instruction Selection</a></li>
<li><a class="reference internal" href="#scheduling-and-formation">Scheduling and Formation</a></li>
<li><a class="reference internal" href="#ssa-based-machine-code-optimization">SSA-based Machine Code Optimization</a></li>
<li><a class="reference internal" href="#register-allocation">Register Allocation</a></li>
<li><a class="reference internal" href="#prologue-epilogue-code-insertion">Prologue/Epilogue Code Insertion</a></li>
<li><a class="reference internal" href="#late-machine-code-optimizations">Late Machine Code Optimizations</a></li>
<li><a class="reference internal" href="#code-emission">Code Emission</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-target-information">General Target Information</a><ul>
<li><a class="reference internal" href="#target-machine-characteristics">Target Machine Characteristics</a></li>
<li><a class="reference internal" href="#subtarget-information">Subtarget Information</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-example-code">Build Example Code</a><ul>
<li><a class="reference internal" href="#step-1-add-xxtargetmachine">Step 1. Add XXTargetMachine</a></li>
<li><a class="reference internal" href="#step-2-add-registerinfo">Step 2. Add RegisterInfo</a></li>
<li><a class="reference internal" href="#step-3-add-asmprinter">Step 3. Add AsmPrinter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-code-generation-sequence">LLVM Code Generation Sequence</a><ul>
<li><a class="reference internal" href="#dag-directed-acyclic-graph">DAG (Directed Acyclic Graph)</a></li>
<li><a class="reference internal" href="#id11">Instruction Selection</a></li>
<li><a class="reference internal" href="#step-4-add-cpu0dagtodagisel">Step 4. Add Cpu0DAGToDAGISel</a></li>
<li><a class="reference internal" href="#step-5-add-prologue-epilogue">Step 5. Add Prologue/Epilogue</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="llvmstructure.html"
                        title="previous chapter">Introduce Cpu0 and LLVM</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="otherinst.html"
                        title="next chapter">Adding arithmetic and local pointer support</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/backendstructure.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="otherinst.html" title="Adding arithmetic and local pointer support"
             >next</a> |</li>
        <li class="right" >
          <a href="llvmstructure.html" title="Introduce Cpu0 and LLVM"
             >previous</a> |</li>
        <li><a href="index.html">Write An LLVM Backend Tutorial For Cpu0</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>