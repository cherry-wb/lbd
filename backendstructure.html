

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LLVM Backend Structure &mdash; Write An LLVM Backend Tutorial For Cpu0</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Write An LLVM Backend Tutorial For Cpu0" href="index.html" />
    <link rel="next" title="Other instructions" href="otherinst.html" />
    <link rel="prev" title="Cpu0 Instruction and LLVM Target Description" href="llvmstructure.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="otherinst.html" title="Other instructions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="llvmstructure.html" title="Cpu0 Instruction and LLVM Target Description"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Write An LLVM Backend Tutorial For Cpu0</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="llvm-backend-structure">
<h1>LLVM Backend Structure<a class="headerlink" href="#llvm-backend-structure" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduces the LLVM backend class inheritance tree and class members
first. Next, we follow the LLVM backend structure and add class implementation one
by one in each section. In this chapter, we need some compiler knowledge, like
<a class="reference external" href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/Instruction_selection">instruction
selection</a>, we will introduce
them when needed. At the end of this chapter, we will have a backend being able
to compile LLVM IR into cpu0 assembly code.</p>
<p>The code added in this chapter are common in every LLVM backend, the only difference
are their name. In fact, since Cpu0 is similar to Mips we copy most of the code from
the Mips backend. In this chapter, we will focus on the relationship between classes
involved in writing a LLVM backend. Once knowing the overall structure, you can
quickly create a simple backend from scratch.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>首先介紹編譯的基本知識，編譯流程可以簡化成 <a class="pageref" href="#compilation-pipeline">figure  1</a> 。
源語言 (代碼) 經過編譯器前端解析成編譯器內部的中間表示，並在此階段優化代碼，最後
產生目標平台語言。<a class="pageref" href="#compilation-flow">figure  2</a> 展示了更進一步的編譯流程。</p>
<div class="align-center figure" id="compilation-pipeline">
<img alt="_images/compilation_pipeline.png" src="_images/compilation_pipeline.png" />
<p class="caption">Figure 1: Compilation Pipeline</p>
</div>
<div class="align-center figure" id="compilation-flow">
<img alt="_images/compilation_flow_part_1.png" src="_images/compilation_flow_part_1.png" />
<p class="caption">Figure 2: Compilation Flow</p>
</div>
<p>LLVM 後端的四大功能標明在 <a class="pageref" href="#llvm-backend">figure  3</a> 。</p>
<ol class="arabic simple">
<li>將 LLVM IR 編譯成匯編文本文件: 傳統的靜態編譯。</li>
<li>將 LLVM IR 編譯成目標二進制文件: .o file writer。</li>
<li>將匯編文本文件轉譯為目標二進製文件: 匯編。</li>
<li>將目標二進制文件還原為匯編文本文件: 反匯編。</li>
</ol>
<div class="align-center figure" id="llvm-backend">
<img alt="_images/llvm_backend.png" src="_images/llvm_backend.png" />
<p class="caption">Figure 3: LLVM 後端</p>
</div>
</div>
<div class="section" id="step-0-build-example-code">
<h2>Step 0. Build Example Code<a class="headerlink" href="#step-0-build-example-code" title="Permalink to this headline">¶</a></h2>
<p>We build our example code first, then add components step by step.</p>
<ol class="arabic">
<li><p class="first">Prepare the source code.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">cd </span>cpu0
<span class="nv">$ </span>mkdir -p 3/src; <span class="nb">cd </span>3/src
<span class="nv">$ </span>cp -rf ../../2/src/* .
<span class="nv">$ </span>cp -rf <span class="nv">$Example_SRC</span>/3/1/Cpu0/ lib/Target/
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Build</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>mkdir debug; <span class="nb">cd </span>debug
<span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -DCMAKE_C_COMPILER<span class="o">=</span>clang <span class="se">\</span>
  -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;Mips;Cpu0&quot;</span> <span class="se">\</span>
  -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug -G <span class="s2">&quot;Unix Makefiles&quot;</span> ../src/
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="step-1-add-xxtargetmachine">
<h2>Step 1. Add XXTargetMachine<a class="headerlink" href="#step-1-add-xxtargetmachine" title="Permalink to this headline">¶</a></h2>
<p>The role of TargetMachine in the LLVM backend structure is shown in <a class="pageref" href="#target-machine">figure  4</a>. <a class="reference external" href="http://llvm.org/docs/CommandGuide/llc.html">llc</a> is LLVM static compiler.
When you invoke <tt class="docutils literal"><span class="pre">llc</span></tt> command with option <tt class="docutils literal"><span class="pre">-march=XX</span></tt>, it will trigger the
corresponding callback functions.</p>
<div class="align-center figure" id="target-machine">
<img alt="_images/target_machine.png" src="_images/target_machine.png" />
<p class="caption">Figure 4: The role of TargetMachine</p>
</div>
<p><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine">Target Machine</a> is
a base class for targets implemented with the LLVM target-independent code generator.
You should define a <tt class="docutils literal"><span class="pre">XXTargetMachine</span></tt> class which inherit class <tt class="docutils literal"><span class="pre">LLVMTargetMachine</span></tt>,
where XX is your target name. In our tutorial we name it as <tt class="docutils literal"><span class="pre">Cpu0TargetMachine</span></tt>.
Class Cpu0TargetMachine has data members which define target layout, instruction
information, frame/stack ...etc. The Cpu0TargetMachine contents as follows,</p>
<div class="highlight-c++" id="cpu0-target-machine"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.h - Define TargetMachine for Cpu0 -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of TargetMachine.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETMACHINE_H</span>
<span class="cp">#define CPU0TARGETMACHINE_H</span>

<span class="cp">#include &quot;Cpu0FrameLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0ISelLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0SelectionDAGInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetData.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">formatted_raw_ostream</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LLVMTargetMachine</span> <span class="p">{</span>
    <span class="n">Cpu0Subtarget</span>       <span class="n">Subtarget</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">TargetData</span>    <span class="n">DataLayout</span><span class="p">;</span> <span class="c1">// Calculates type size &amp; alignment</span>
    <span class="n">Cpu0InstrInfo</span>       <span class="n">InstrInfo</span><span class="p">;</span>	<span class="c1">//- Instructions</span>
    <span class="n">Cpu0FrameLowering</span>   <span class="n">FrameLowering</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0TargetLowering</span>  <span class="n">TLInfo</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0SelectionDAGInfo</span> <span class="n">TSInfo</span><span class="p">;</span>	<span class="c1">//- Map .bc DAG to backend DAG</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                      <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0InstrInfo</span>   <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">FrameLowering</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0Subtarget</span>   <span class="o">*</span><span class="n">getSubtargetImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetData</span>      <span class="o">*</span><span class="n">getTargetData</span><span class="p">()</span>    <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">DataLayout</span><span class="p">;}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetLowering</span> <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TLInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0SelectionDAGInfo</span><span class="o">*</span> <span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TSInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Pass Pipeline Configuration</span>
    <span class="k">virtual</span> <span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">);</span>
  <span class="p">};</span>

<span class="c1">/// Cpu0ebTargetMachine - Cpu032 big endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0ebTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">/// Cpu0elTargetMachine - Cpu032 little endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0elTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>Due to the OO design of LLVM, most member functions are already implemented by
base classes. We only need to override some member functions for our target machine.</p>
<p>After writing up our target description files, <tt class="docutils literal"><span class="pre">llvm-tblgen</span></tt> generates C++ files
included by others. Take <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.td</span></tt> as an example, <tt class="docutils literal"><span class="pre">llvm-tblgen</span></tt> generates
<tt class="docutils literal"><span class="pre">Cpu0GenInstrInfo.inc</span></tt> from <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.td</span></tt>. Then <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.h</span></tt> defines
<tt class="docutils literal"><span class="pre">GET_INSTRINFO_HEADER</span></tt> marco so that it can get code it needs from <tt class="docutils literal"><span class="pre">Cpu0GenInstrInfo.inc</span></tt>
Below is the code fragment from Cpu0GenInstrInfo.inc.</p>
<p>Code between <tt class="docutils literal"><span class="pre">#if</span> <span class="pre">def</span>&nbsp; <span class="pre">GET_INSTRINFO_HEADER</span></tt> and <tt class="docutils literal"><span class="pre">#endif</span> <span class="pre">//</span> <span class="pre">GET_INSTRINFO_HEADER</span></tt>
will be extracted by <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.h.</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td </span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER </span>
<span class="cp">#undef GET_INSTRINFO_HEADER </span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span> 
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span> 
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
<span class="p">};</span> 
<span class="p">}</span> <span class="c1">// End llvm namespace </span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>

<span class="c1">//- Cpu0InstrInfo.h extracts above code by defining GET_INSTRINFO_HEADER</span>
<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Reference Write An LLVM Backend web site <a class="footnote-reference" href="#id11" id="id2">[1]</a>.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>cp -rf <span class="nv">$Example_SRC</span>/3/1/Cpu0 lib/Target
</pre></div>
</div>
</div></blockquote>
<p>We add the following files in this section, and we have to modify CMakefile.txt
to include thhose new added C++ files.</p>
<ol class="arabic simple">
<li>Cpu0TargetMachine.[h,cpp]</li>
<li>Cpu0Subtarget.[h,cpp]</li>
<li>Cpu0InstrInfo.[h,cpp]</li>
<li>Cpu0FrameLowering.[h,cpp]</li>
<li>Cpu0TargetLowering.[h,cpp]</li>
<li>Cpu0SelectionDAGInfo.[h,cpp]</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp"># CMakeLists.txt </span>
<span class="p">...</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span> 
  <span class="n">Cpu0ISelLowering</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0InstrInfo</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0FrameLowering</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0Subtarget</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0TargetMachine</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="n">Cpu0SelectionDAGInfo</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="p">)</span>
</pre></div>
</div>
<p>Please follow commands below to build example code for this section.</p>
<ol class="arabic">
<li><p class="first">Prepare the source code.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">cd </span>cpu0
<span class="nv">$ </span>mkdir -p 3/1/src; <span class="nb">cd </span>3/1/src
<span class="nv">$ </span>cp -rf ../../../2/src/* .
<span class="nv">$ </span>cp -rf <span class="nv">$Example_SRC</span>/3/1/Cpu0/ lib/Target/
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Build</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>mkdir debug; <span class="nb">cd </span>debug
<span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -DCMAKE_C_COMPILER<span class="o">=</span>clang <span class="se">\</span>
  -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;Mips;Cpu0&quot;</span> <span class="se">\</span>
  -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug -G <span class="s2">&quot;Unix Makefiles&quot;</span> ../src/
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="step-2-add-registerinfo">
<h2>Step 2. Add RegisterInfo<a class="headerlink" href="#step-2-add-registerinfo" title="Permalink to this headline">¶</a></h2>
<p>class <cite>Cpu0InstrInfo</cite> has a data member of class <cite>Cpu0RegisterInfo</cite>.
This section adds class <cite>Cpu0RegisterInfo</cite>, then includes it in <cite>Cpu0InstrInfo.h</cite>
and <cite>Cpu0TargetMachine.h</cite>. Finally, we modify CMakefile.txt to add our new added
file <cite>Cpu0RegisterInfo.cpp</cite>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0InstrInfo.h</span>
<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span> 
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span> 
  <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="n">RI</span><span class="p">;</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span> 

  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 

<span class="k">public</span><span class="o">:</span> 
<span class="p">};</span>

<span class="c1">//- Cpu0InstrInfo.cpp</span>
<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span> 
  <span class="o">:</span> 
    <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span> 
    <span class="n">RI</span><span class="p">(</span><span class="o">*</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtargetImpl</span><span class="p">(),</span> <span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{}</span> 

<span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="n">RI</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="c1">//  Cpu0TargetMachine.h</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">*</span><span class="n">getRegisterInfo</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>
    <span class="p">}</span>

<span class="cp"># CMakeLists.txt </span>
<span class="p">...</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span> 
  <span class="p">...</span>
  <span class="n">Cpu0RegisterInfo</span><span class="p">.</span><span class="n">cpp</span> 
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>Now, let&#8217;s replace 3/1/Cpu0 with 3/2/Cpu0 of adding register class definition
and rebuild.</p>
<ol class="arabic">
<li><p class="first">Prepare the source code.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">cd </span>cpu0/3
<span class="nv">$ </span>mkdir -p 2/src; <span class="nb">cd </span>2/src
<span class="nv">$ </span>cp -rf ../../1/src/* .
<span class="nv">$ </span>cp -rf <span class="nv">$Example_SRC</span>/3/2/Cpu0/ lib/Target/
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Build</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>mkdir debug; <span class="nb">cd </span>debug
<span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -DCMAKE_C_COMPILER<span class="o">=</span>clang <span class="se">\</span>
  -DLLVM_TARGETS_TO_BUILD<span class="o">=</span><span class="s2">&quot;Mips;Cpu0&quot;</span> <span class="se">\</span>
  -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug -G <span class="s2">&quot;Unix Makefiles&quot;</span> ../src/
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
<p>Now, let&#8217;s run <tt class="docutils literal"><span class="pre">llc</span></tt> to compile a LLVM bitcode to see what happen.</p>
<ol class="arabic">
<li><p class="first">Prepare LLVM bitcode.</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>clang -c example/input/ch3.cpp -emit-llvm -o ch3.bc
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Compile</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o ch3.cpu0.s
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
<div class="highlight-bash"><pre>llc: /cpu0/3/2/src/lib/CodeGen/LLVMTargetMachine.cpp:78: llvm::LLVMTargetMachine::LLVMTargetMachine(const llvm::Target &amp;, llvm::StringRef, llvm::StringRef, llvm::StringRef, llvm::TargetOptions, Reloc::Model, CodeModel::Model, CodeGenOpt::Level): Assertion `AsmInfo &amp;&amp; "MCAsmInfo not initialized." "Make sure you include the correct TargetSelect.h" "and that InitializeAllTargetMCs() is being invoked!"' failed.
Stack dump:
0.      Program arguments: ./bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s
Aborted</pre>
</div>
<p>Look into the assertion in above error message, it tell us that we don&#8217;t have
a ASMPrinter for our target to print assembly. We will add it in next section.</p>
</div>
<div class="section" id="step-3-add-asmprinter">
<h2>Step 3. Add AsmPrinter<a class="headerlink" href="#step-3-add-asmprinter" title="Permalink to this headline">¶</a></h2>
<p>First, wee modify <tt class="docutils literal"><span class="pre">Cpu0.td</span></tt> to add support for ASMPrinter. LLVM now has a newer
ASMPrinter called MCAsmWriter, we explictly say we will support MCAsmWriter.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Proc</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">Name</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">SubtargetFeature</span><span class="o">&gt;</span> <span class="n">Features</span><span class="o">&gt;</span> 
 <span class="o">:</span> <span class="n">Processor</span><span class="o">&lt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">Cpu0GenericItineraries</span><span class="p">,</span> <span class="n">Features</span><span class="o">&gt;</span><span class="p">;</span> 

<span class="n">def</span> <span class="o">:</span> <span class="n">Proc</span><span class="o">&lt;</span><span class="s">&quot;cpu032&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">FeatureCpu032</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> 

<span class="n">def</span> <span class="n">Cpu0AsmWriter</span> <span class="o">:</span> <span class="n">AsmWriter</span> <span class="p">{</span> 
  <span class="n">string</span> <span class="n">AsmWriterClassName</span>  <span class="o">=</span> <span class="s">&quot;InstPrinter&quot;</span><span class="p">;</span> 
  <span class="n">bit</span> <span class="n">isMCAsmWriter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
<span class="p">}</span> 

<span class="n">def</span> <span class="n">Cpu0</span> <span class="o">:</span> <span class="n">Target</span> <span class="p">{</span> 
  <span class="n">let</span> <span class="n">InstructionSet</span> <span class="o">=</span> <span class="n">Cpu0InstrInfo</span><span class="p">;</span> 
  <span class="n">let</span> <span class="n">AssemblyWriters</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmWriter</span><span class="p">];</span> 
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">llvm-tblgen</span></tt> will generate <tt class="docutils literal"><span class="pre">Cpu0GenAsmWrite.inc</span></tt> included by <tt class="docutils literal"><span class="pre">Cpu0InstPrinter.cpp</span></tt>
which will be added soon. <tt class="docutils literal"><span class="pre">Cpu0GenAsmWrite.inc</span></tt> implements two member functions:
<tt class="docutils literal"><span class="pre">printInstruction</span></tt> and <tt class="docutils literal"><span class="pre">getRegisterName</span></tt> for class <tt class="docutils literal"><span class="pre">Cpu0InstPrinter</span></tt>.
Both of them are auto-generated from target description files we added before,
i.e., <tt class="docutils literal"><span class="pre">Cpu0InstrInfo.td</span></tt> and <tt class="docutils literal"><span class="pre">Cpu0RegisterInfo.td</span></tt>. The last thing we have to
do is adding class <tt class="docutils literal"><span class="pre">Cpu0InstPrinter</span></tt>, then include <tt class="docutils literal"><span class="pre">Cpu0GenAsmWrite.inc</span></tt> in it.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//-  Cpu0InstPrinter.cpp</span>
<span class="cp">#include &quot;Cpu0GenAsmWriter.inc&quot; </span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printRegName</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RegNo</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> 
<span class="c1">//- getRegisterName(RegNo) defined in Cpu0GenAsmWriter.inc which came from</span>
<span class="c1">//-  Cpu0.td indicate. </span>
  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;$&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">RegNo</span><span class="p">)).</span><span class="n">lower</span><span class="p">();</span> 
<span class="p">}</span> 

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printInst</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> 
                                <span class="n">StringRef</span> <span class="n">Annot</span><span class="p">)</span> <span class="p">{</span> 
<span class="c1">//- printInstruction(MI, O) defined in Cpu0GenAsmWriter.inc which came from</span>
<span class="c1">//-  Cpu0.td indicate. </span>
  <span class="n">printInstruction</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span> 
  <span class="n">printAnnotation</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">Annot</span><span class="p">);</span> 
<span class="p">}</span> 
</pre></div>
</div>
<p>Next, add files below into new subdirectory <tt class="docutils literal"><span class="pre">MCTargetDesc</span></tt>.</p>
<ol class="arabic simple">
<li>Cpu0AsmPrinter.[h,cpp]</li>
<li>Cpu0MCInstLower.[h,cpp]</li>
<li>Cpu0BaseInfo.[h,cpp]</li>
<li>Cpu0FixupKinds.[h,cpp]</li>
<li>Cpu0MCAsmInfo.[h,cpp]</li>
</ol>
<p>We register our target MCAsmInfo and InstPrinter in <tt class="docutils literal"><span class="pre">Cpu0MCTargetDesc.cpp</span></tt>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//-  Cpu0MCTargetDesc.cpp</span>
<span class="k">static</span> <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">createCpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">MAI</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">);</span>

  <span class="n">MachineLocation</span> <span class="n">Dst</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">);</span>
  <span class="n">MachineLocation</span> <span class="n">Src</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">addInitialFrameState</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Dst</span><span class="p">,</span> <span class="n">Src</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MAI</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCInstPrinter</span> <span class="o">*</span><span class="n">createCpu0MCInstPrinter</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">SyntaxVariant</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCAsmInfo</span> <span class="o">&amp;</span><span class="n">MAI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MII</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0InstPrinter</span><span class="p">(</span><span class="n">MAI</span><span class="p">,</span> <span class="n">MII</span><span class="p">,</span> <span class="n">MRI</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Register the MC asm info.</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>

  <span class="c1">// Register the MCInstPrinter.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we register AsmPrinter in <tt class="docutils literal"><span class="pre">Cpu0AsmPrinter.cpp</span></tt>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0AsmPrinter.cpp</span>

<span class="c1">// Force static initialization.</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0AsmPrinter</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This sections adds two subdirectories: <tt class="docutils literal"><span class="pre">InstPrinter</span></tt> and <tt class="docutils literal"><span class="pre">MCTargetDesc</span></tt>.
You have to modify top-level LLVMBuild.txt and CMakefile.txt accordingly,
and add LLVMBuild.txt and CMakefile.txt into those subdirectories also.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//-  top-level LLVMBuild.txt</span>

<span class="p">[</span><span class="n">common</span><span class="p">]</span> 
<span class="n">subdirectories</span> <span class="o">=</span> <span class="n">InstPrinter</span> <span class="n">MCTargetDesc</span> <span class="n">TargetInfo</span> 

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span> 
<span class="p">...</span>
<span class="cp"># Please enable asmprinter</span>
<span class="n">has_asmprinter</span> <span class="o">=</span> <span class="mi">1</span> 
<span class="p">...</span>

<span class="p">[</span><span class="n">component_1</span><span class="p">]</span> 
<span class="cp"># Add AsmPrinter Cpu0AsmPrinter</span>
<span class="n">required_libraries</span> <span class="o">=</span> <span class="n">AsmPrinter</span> <span class="n">CodeGen</span> <span class="n">Core</span> <span class="n">MC</span> <span class="n">Cpu0AsmPrinter</span> <span class="n">Cpu0Desc</span> <span class="n">Cpu0Info</span>
</pre></div>
</div>
<p>O.K., let&#8217;s build example code, then run <tt class="docutils literal"><span class="pre">llc</span></tt> as before. You will see
error below:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>./bin/llc -march<span class="o">=</span>cpu0 ../../2/debug/ch3.bc
./bin/llc: target does not support generation of this file <span class="nb">type</span>!
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">llc</span></tt> fails to compile LLVM IR into target machine code since we don&#8217;t
implement class <tt class="docutils literal"><span class="pre">Cpu0DAGToDAGISel</span></tt> yet. Before moving on, we will introduce
LLVM code generation sequence, DAG, and instruction selection in next three
sections.</p>
</div>
<div class="section" id="llvm-code-generation-sequence">
<h2>LLVM Code Generation Sequence<a class="headerlink" href="#llvm-code-generation-sequence" title="Permalink to this headline">¶</a></h2>
<p>Following content came from
&#8220;Design and Implementation of a TriCore Backend for the LLVM Compiler Framework&#8221;
<a class="footnote-reference" href="#id16" id="id3">[6]</a> section 4.2 Code Generation Process.</p>
<p><a class="pageref" href="#code-generation-sequence">figure  5</a>
gives an overview of LLVM code generation sequence.</p>
<div class="align-center figure" id="code-generation-sequence">
<img alt="_images/code_generation_sequence.png" src="_images/code_generation_sequence.png" />
<p class="caption">Figure 5: LLVM code generation sequence</p>
</div>
<p>LLVM IR is a Static Single Assignment (SSA) <a class="footnote-reference" href="#id12" id="id4">[2]</a> based representation.
LLVM provides infinite virtual registers which can hold value of primitive
type (integral, floating point, or pointer).
So, every operand can save in different virtual register in LLVM SSA
representation.
Comment is prefixed with <tt class="docutils literal"><span class="pre">;</span></tt> in LLVM representation.</p>
<p>Following is a LLVM IR example.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">store</span> <span class="n">i32</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>  <span class="p">;</span> <span class="n">store</span> <span class="n">i32</span> <span class="n">type</span> <span class="n">of</span> <span class="mi">0</span> <span class="n">to</span> <span class="k">virtual</span> <span class="k">register</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span> <span class="n">is</span>
                      <span class="p">;</span>  <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span> <span class="p">;</span> <span class="n">store</span> <span class="o">%</span><span class="n">b</span> <span class="n">contents</span> <span class="n">to</span> <span class="o">%</span><span class="n">c</span> <span class="n">point</span> <span class="n">to</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="n">isi32</span> <span class="n">type</span> <span class="k">virtual</span>
                      <span class="p">;</span>  <span class="k">register</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span> <span class="n">is</span> <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span><span class="p">.</span>
<span class="o">%</span><span class="n">a1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>    <span class="p">;</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">value</span> <span class="n">where</span> <span class="o">%</span><span class="n">a</span> <span class="n">point</span> <span class="n">to</span> <span class="n">and</span> <span class="n">assign</span> <span class="n">the</span>
                      <span class="p">;</span>  <span class="n">memory</span> <span class="n">value</span> <span class="n">to</span> <span class="o">%</span><span class="n">a1</span>
<span class="o">%</span><span class="n">a3</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a2</span><span class="p">,</span> <span class="mi">1</span>  <span class="p">;</span> <span class="n">add</span> <span class="o">%</span><span class="n">a2</span> <span class="n">and</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">save</span> <span class="n">to</span> <span class="o">%</span><span class="n">a3</span>
</pre></div>
</div>
<p>We explain the code generation process as below.
If you don&#8217;t feel comfortable, please check tricore_llvm.pdf section 4.2 first.
You can  read “The LLVM Target-Independent Code Generator” from <a class="footnote-reference" href="#id13" id="id5">[3]</a>
and “LLVM Language Reference Manual” from <a class="footnote-reference" href="#id14" id="id6">[4]</a>
before go ahead, but we think read section
4.2 of tricore_llvm.pdf is enough.
We suggest you read the web site documents as above only when you are still not
quite understand, even though you have read this section and next 2 sections
article for DAG and Instruction Selection.</p>
<p>&#8220;Design and Implementation of a TriCore Backend for the LLVM Compiler Framework&#8221;
<a class="footnote-reference" href="#id15" id="id7">[5]</a> section 4.2.</p>
<ol class="arabic">
<li><p class="first">Instruction Selection</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// In this stage, transfer the llvm opcode into machine opcode, but the operand</span>
    <span class="c1">// still is llvm virtual operand.</span>
    <span class="n">store</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span> <span class="c1">// store 0 of i16 type to where virtual register %a</span>
                         <span class="c1">// point to</span>

<span class="o">=&gt;</span>  <span class="n">addiu</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Scheduling and Formation</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// In this stage, reorder the instructions sequence for optimization in</span>
    <span class="c1">// instructions cycle or in register pressure.</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">5</span> <span class="p">;</span> <span class="n">st</span> <span class="o">%</span><span class="n">a</span> <span class="n">to</span> <span class="o">*</span><span class="p">(</span><span class="o">%</span><span class="n">b</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span>

    <span class="c1">// Transfer above instructions order as follows. In RISC architecture like</span>
    <span class="c1">// Mips, since the &quot;ld %c&quot; depends on previous instruction &quot;st %c&quot;, it must</span>
    <span class="c1">// wait more than 1 cycles. Therefore, the ld cannot follow st immediately.</span>
<span class="o">=&gt;</span>  <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>

    <span class="c1">// If without reordering instructions, a instruction nop which does nothing</span>
    <span class="c1">// must be inserted as a bubble, contribute one instruction cycle more than</span>
    <span class="c1">// optimization.</span>
    <span class="c1">// Actually, Mips is scheduled with hardware dynamically and will insert nop</span>
    <span class="c1">// between st and ld instructions if compiler didn&#39;t insert nop.</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
<span class="o">=&gt;</span>  <span class="n">nop</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>

    <span class="c1">// Minimum register pressure</span>
    <span class="c1">//</span>
    <span class="c1">// Suppose %c is alive after this basic block (meaning %c will be</span>
    <span class="c1">// used after this basic block), %a and %b are not dead after this</span>
    <span class="c1">// one. The following non-reordering version need 3 registers at least.</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>

    <span class="c1">// The reordering version need 2 registers only (by allocate %a and %b in the same</span>
    <span class="c1">// register)</span>
<span class="o">=&gt;</span>  <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">SSA-based Machine Code Optimization</p>
<blockquote>
<div><p>For example, common expression remove, shown in next section DAG.</p>
</div></blockquote>
</li>
<li><p class="first">Register Allocation</p>
<blockquote>
<div><p>Allocate real register for virtual register.</p>
</div></blockquote>
</li>
<li><p class="first">Prologue/Epilogue Code Insertion</p>
<blockquote>
<div><p>Explain in section Add Prologue/Epilogue functions</p>
</div></blockquote>
</li>
<li><p class="first">Late Machine Code Optimizations</p>
<blockquote>
<div><p>Any &#8220;last-minute&#8221; peephole optimizations of the final machine code can
be applied during this phase. For example, replace &#8220;x = x * 2&#8221; by
&#8220;x = x &lt; 1&#8221; for integer operand.</p>
</div></blockquote>
</li>
<li><p class="first">Code Emission</p>
<blockquote>
<div><p>Finally, the completed machine code is emitted. For static compilation,
the end result is an assembly code file; for JIT compilation, the opcodes
of the machine instructions are written into memory.</p>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="dag-directed-acyclic-graph">
<h2>DAG (Directed Acyclic Graph)<a class="headerlink" href="#dag-directed-acyclic-graph" title="Permalink to this headline">¶</a></h2>
<p>Many important techniques for local optimization begin by transforming a basic
block into DAG. For example, the basic block code and it&#8217;s corresponding DAG as
<a class="reference internal" href="#backendstructure-f6"><em>DAG example</em></a>.</p>
<div class="figure align-center" id="backendstructure-f6">
<img alt="_images/61.png" src="_images/61.png" />
<p class="caption">Figure 6: DAG example</p>
</div>
<p>If b is not live on exit from the block, then we can do common expression
remove to get the following code.</p>
<div class="highlight-c++"><pre>a = b + c
d = a – d
c = d + c
</pre>
</div>
<p>As you can imagine, the common expression remove can apply in IR or machine
code.</p>
<p>DAG like a tree which opcode is the node and operand (register and
const/immediate/offset) is leaf.
It can also be represented by list as prefix order in tree.
For example, (+ b, c), (+ b, 1) is IR DAG representation.</p>
</div>
<div class="section" id="id8">
<h2>Instruction Selection<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>In the compiler backend, we need to translate compiler intermediate representation
, i.e., IR code into machine code at instruction selection stage <a class="footnote-reference" href="#id16" id="id9">[6]</a>.</p>
<p><a class="pageref" href="#ir-and-machine-code">figure  7</a> shows a simple example to illustrate the
before and after instruction selection.</p>
<div class="figure align-center" id="ir-and-machine-code">
<img alt="_images/ir_and_machine_code.png" src="_images/ir_and_machine_code.png" />
<p class="caption">Figure 7: IR and it&#8217;s corresponding machine instruction</p>
</div>
<p>For machine instruction selection, the better solution is represent IR and
machine instruction by DAG.
In <a class="pageref" href="#instruction-tree-patterns">figure  8</a>, we skip the register leaf.
The rj + rk is IR DAG representation (for symbol notation, not llvm SSA form).
ADD is machine instruction.</p>
<div class="figure align-center" id="instruction-tree-patterns">
<img alt="_images/instruction_tree_patterns.png" src="_images/instruction_tree_patterns.png" />
<p class="caption">Figure 8: Instruction DAG representation</p>
</div>
<p>The IR DAG and machine instruction DAG can also represented as list.
For example, (+ ri, rj), (- ri, 1) are lists for IR DAG; (ADD ri, rj),
(SUBI ri, 1) are lists for machine instruction DAG.</p>
<p>Now, let&#8217;s recall the ADDiu instruction defined on Cpu0InstrInfo.td in the
previous chapter.
And It will expand to the following Pattern as mentioned in section Write td
(Target Description) of the previous chapter as follows,</p>
<div class="highlight-c++"><pre>def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

Pattern = [(set CPURegs:$ra, (add RC:$rb, immSExt16:$imm16))]
</pre>
</div>
<p>This pattern meaning the IR DAG node <strong>add</strong> can translate into machine
instruction DAG node ADDiu by pattern match mechanism.
Similarly, the machine instruction DAG node LD and ST can be got from IR DAG
node <strong>load</strong> and <strong>store</strong>.</p>
<p>Some cpu/fpu (floating point processor) has multiply-and-add floating point
instruction, fmadd.
It can be represented by DAG list (fadd (fmul ra, rc), rb).
For this implementation, we can assign fmadd DAG pattern to instruction td as
follows,</p>
<div class="highlight-c++"><pre>def FMADDS : AForm_1&lt;59, 29,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
                    "fmadds $FRT, $FRA, $FRC, $FRB",
                    [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                                           F4RC:$FRB))]&gt;;
</pre>
</div>
<p>Similar with ADDiu, [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
F4RC:$FRB))] is the pattern which include node <strong>fmul</strong> and node <strong>fadd</strong>.</p>
<p>Now, for the following basic block notation IR and llvm SSA IR code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">...</span>

<span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">fmul</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span>
<span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fadd</span> <span class="o">%</span><span class="n">d</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The llvm SelectionDAG Optimization Phase (is part of Instruction Selection
Process) prefered to translate this 2 IR DAG node (fmul %a, %b) (fadd %d, %c)
into one machine instruction DAG node (<strong>fmadd</strong> %a, %c, %b), than translate
them into 2 machine instruction nodes <strong>fmul</strong> and <strong>fadd</strong>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fmadd</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>As you can see, the IR notation representation is easier to read then llvm SSA
IR form.
So, we  use the notation form in this book sometimes.</p>
<p>For the following basic block code,</p>
<div class="highlight-c++"><pre>a = b + c		// in notation IR form
d = a – d
%e = fmadd %a, %c, %b	// in llvm SSA IR form
</pre>
</div>
<p>We can apply <em class="xref std std-ref">backendstructure_f7</em> Instruction tree pattern to get the
following machine code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">load</span>	<span class="n">rb</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span> <span class="c1">// assume b allocate in sp+8, sp is stack point register</span>
<span class="n">load</span>	<span class="n">rc</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span>
<span class="n">add</span>	<span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">load</span>	<span class="n">rd</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">24</span><span class="p">);</span>
<span class="n">sub</span>	<span class="n">rd</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">fmadd</span>	<span class="n">re</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rb</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="step-4-add-cpu0dagtodagisel">
<h2>Step 4. Add Cpu0DAGToDAGISel<a class="headerlink" href="#step-4-add-cpu0dagtodagisel" title="Permalink to this headline">¶</a></h2>
<p>The IR DAG to machine instruction DAG transformation is introduced in the
previous section.
Now, let&#8217;s check what IR DAG node the file ch3.bc has. List ch3.ll as follows,</p>
<div class="highlight-c++"><pre>// ch3.ll
define i32 @main() nounwind uwtable { 
%1 = alloca i32, align 4 
store i32 0, i32* %1 
ret i32 0 
} 
</pre>
</div>
<p>As above, ch3.ll use the IR DAG node <strong>store</strong>, <strong>ret</strong>. Actually, it also use
<strong>add</strong> for sp (stack point) register adjust.
So, the definitions in Cpu0InstInfo.td as follows is enough.
IR DAG is defined in file  include/llvm/Target/TargetSelectionDAG.td.</p>
<div class="highlight-c++"><pre>/// Load and Store Instructions 
///  aligned 
defm LD      : LoadM32&lt;0x00,  "ld",  load_a&gt;; 
defm ST      : StoreM32&lt;0x01, "st",  store_a&gt;; 

/// Arithmetic Instructions (ALU Immediate)
//def LDI     : MoveImm&lt;0x08, "ldi", add, simm16, immSExt16, CPURegs&gt;;
// add defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1, 
    isBarrier=1, hasCtrlDep=1 in 
  def RET : FJ &lt;0x2C, (outs), (ins CPURegs:$target), 
                "ret\t$target", [(Cpu0Ret CPURegs:$target)], IIBranch&gt;;
</pre>
</div>
<p>Add  class Cpu0DAGToDAGISel (Cpu0ISelDAGToDAG.cpp) to CMakeLists.txt, and add
following fragment to Cpu0TargetMachine.cpp,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  Cpu0TargetMachine.cpp</span>
<span class="p">...</span>
<span class="c1">// Install an instruction selector pass using</span>
<span class="c1">// the ISelDag to gen Cpu0 code.</span>
<span class="kt">bool</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addInstSelector</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">PM</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">getCpu0TargetMachine</span><span class="p">()));</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//  Cpu0ISelDAGToDAG.cpp</span>
<span class="c1">/// createCpu0ISelDag - This pass converts a legalized DAG into a </span>
<span class="c1">/// CPU0-specific DAG, ready for instruction scheduling. </span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0DAGToDAGISel</span><span class="p">(</span><span class="n">TM</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>
</div>
<p>This version adding the following code in Cpu0InstInfo.cpp to enable debug
information which called by llvm at proper time.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0InstInfo.cpp</span>
<span class="p">...</span>
<span class="n">MachineInstr</span><span class="o">*</span>
<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">emitFrameIndexDebugValue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIx</span><span class="p">,</span>
                                        <span class="n">uint64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">MDNode</span> <span class="o">*</span><span class="n">MDPtr</span><span class="p">,</span>
                                        <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">DBG_VALUE</span><span class="p">))</span>
    <span class="p">.</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FrameIx</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">).</span><span class="n">addMetadata</span><span class="p">(</span><span class="n">MDPtr</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&amp;*</span><span class="n">MIB</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Build 3/4, run it, we find the error message in 3/3 is gone. The new error
message for 3/4 as follows,</p>
<div class="highlight-c++"><pre>[Gamma@localhost InputFiles]$ /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/
bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s 
Target didn't implement TargetInstrInfo::storeRegToStackSlot! 
UNREACHABLE executed at /usr/local/llvm/3.1.test/cpu0/1/src/include/llvm/Target/
TargetInstrInfo.h:390! 
Stack dump: 
0.	Program arguments: /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/bin/llc
 -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s 
1.	Running pass 'Function Pass Manager' on module 'ch3.bc'. 
2.	Running pass 'Prologue/Epilogue Insertion &amp; Frame Finalization' on function 
'@main' 
Aborted (core dumped) 
</pre>
</div>
</div>
<div class="section" id="step-5-add-prologue-epilogue">
<h2>Step 5. Add Prologue/Epilogue<a class="headerlink" href="#step-5-add-prologue-epilogue" title="Permalink to this headline">¶</a></h2>
<p>Following came from
&#8220;Design and Implementation of a TriCore Backend for the LLVM Compiler Framework&#8221;
<a class="footnote-reference" href="#id16" id="id10">[6]</a> section 4.4.2.</p>
<p>For some target architectures, some aspects of the target architecture’s
register set are dependent upon variable factors and have to be determined at
runtime.
As a consequence, they cannot be generated statically from a TableGen
description – although that would be possible for the bulk of them in the case
of the TriCore backend.
Among them are the following points:</p>
<ul class="simple">
<li>Callee-saved registers. Normally, the ABI specifies a set of registers that a function must save on entry and restore on return if their contents are possibly modified during execution.</li>
<li>Reserved registers. Although the set of unavailable registers is already defined in the TableGen file, TriCoreRegisterInfo contains a method that marks all non-allocatable register numbers in a bit vector.</li>
</ul>
<p>The following methods are implemented:</p>
<ul class="simple">
<li>emitPrologue() inserts prologue code at the beginning of a function. Thanks to TriCore’s context model, this is a trivial task as it is not required to save any registers manually. The only thing that has to be done is reserving space for the function’s stack frame by decrementing the stack pointer. In addition, if the function needs a frame pointer, the frame register %a14 is set to the old value of the stack pointer beforehand.</li>
<li>emitEpilogue() is intended to emit instructions to destroy the stack frame and restore all previously saved registers before returning from a function. However, as %a10 (stack pointer), %a11 (return address), and %a14 (frame pointer, if any) are all part of the upper context, no epilogue code is needed at all. All cleanup operations are performed implicitly by the ret instruction.</li>
<li>eliminateFrameIndex() is called for each instruction that references a word of data in a stack slot. All previous passes of the code generator have been addressing stack slots through an abstract frame index and an immediate offset. The purpose of this function is to translate such a reference into a register–offset pair. Depending on whether the machine function that contains the instruction has a fixed or a variable stack frame, either the stack pointer %a10 or the frame pointer %a14 is used as the base register. The offset is computed accordingly. Figure 3.9 demonstrates for both cases how a stack slot is addressed.</li>
</ul>
<p>If the addressing mode of the affected instruction cannot handle the address because the offset is too large (the offset field has 10 bits for the BO addressing mode and 16 bits for the BOL mode), a sequence of instructions is emitted that explicitly computes the effective address. Interim results are put into an unused address register. If none is available, an already occupied address register is scavenged. For this purpose, LLVM’s framework offers a class named RegScavenger that takes care of all the details.</p>
<div class="figure align-center" id="backendstructure-f9">
<img alt="_images/91.png" src="_images/91.png" />
<p class="caption">Figure 9: Addressing of a variable a located on the stack. If the stack frame has a variable size, slot must be addressed relative to the frame pointer</p>
</div>
<p>We will explain the Prologue and Epilogue further by example code.
So for the following llvm IR code, Cpu0 back end will emit the corresponding
machine instructions as follows,</p>
<div class="highlight-c++"><pre>define i32 @main() nounwind uwtable { 
  %1 = alloca i32, align 4 
  store i32 0, i32* %1 
  ret i32 0 
}

	.section .mdebug.abi32
	.previous
	.file	"ch3.bc"
	.text
	.globl	main
	.align	2
	.type	main,@function
	.ent	main                    # @main
main:
	.frame	$sp,8,$lr
	.mask 	0x00000000,0
	.set	noreorder
	.set	nomacro
# BB#0:                                 # %entry
	addiu	$sp, $sp, -8
	addiu	$2, $zero, 0
	st	$2, 4($sp)
	addiu	$sp, $sp, 8
	ret	$lr
	.set	macro
	.set	reorder
	.end	main
$tmp1:
	.size	main, ($tmp1)-main
</pre>
</div>
<p>LLVM get the stack size by parsing IR and counting how many virtual registers
is assigned to local variables. After that, it call emitPrologue().
This function will emit machine instructions to adjust sp (stack pointer
register) for local variables since we don&#8217;t use fp (frame pointer register).
For our example, it will emit the instructions,</p>
<div class="highlight-c++"><pre>addiu	$sp, $sp, -8
</pre>
</div>
<p>The  emitEpilogue will emit “addiu  $sp, $sp, 8”, 8 is the stack size.</p>
<p>Since Instruction Selection and Register Allocation occurs before
Prologue/Epilogue Code Insertion, eliminateFrameIndex() is called after machine
instruction and real register allocated.
It translate the frame index of local variable (%1 and %2 in the following
example) into stack offset according the frame index order upward (stack grow
up downward from high address to low address, 0($sp) is the top, 52($sp) is the
bottom) as follows,</p>
<div class="highlight-c++"><pre>define i32 @main() nounwind uwtable { 
       %1 = alloca i32, align 4 
       %2 = alloca i32, align 4 
      ...
      store i32 0, i32* %1
      store i32 5, i32* %2, align 4 
      ...
      ret i32 0 

=&gt; # BB#0: 
	addiu	$sp, $sp, -56 
$tmp1: 
	addiu	$3, $zero, 0 
	st	$3, 52($sp)   // %1 is the first frame index local variable, so allocate
                      // in 52($sp)
	addiu	$2, $zero, 5 
	st	$2, 48($sp)   // %2 is the second frame index local variable, so 
                      // allocate in 48($sp)
    ...
    ret	$lr
</pre>
</div>
<p>After add these Prologue and Epilogue functions, and build with 3/5/Cpu0.
Now we are ready to compile our example code ch3.bc into cpu0 assembly code.
Following is the command and output file ch3.cpu0.s,</p>
<div class="highlight-c++"><pre>[Gamma@localhost InputFiles]$ /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/
bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o ch3.cpu0.s 
[Gamma@localhost InputFiles]$ cat ch3.cpu0.s 
	.section .mdebug.abi32
	.previous
	.file	"ch3.bc"
	.text
	.globl	main
	.align	2
	.type	main,@function
	.ent	main                    # @main
main:
	.frame	$sp,8,$lr
	.mask 	0x00000000,0
	.set	noreorder
	.set	nomacro
# BB#0:                                 # %entry
	addiu	$sp, $sp, -8
	addiu	$2, $zero, 0
	st	$2, 4($sp)
	addiu	$sp, $sp, 8
	ret	$lr
	.set	macro
	.set	reorder
	.end	main
$tmp1:
	.size	main, ($tmp1)-main
</pre>
</div>
</div>
<div class="section" id="summary-of-this-chapter">
<h2>Summary of this Chapter<a class="headerlink" href="#summary-of-this-chapter" title="Permalink to this headline">¶</a></h2>
<p>We have finished a simple assembler for cpu0 which only support <strong>addiu</strong>,
<strong>st</strong> and <strong>ret</strong> 3 instructions.</p>
<p>We are satisfied with this result.
But you may think “After so many codes we program, and just get the 3
instructions”.
The point is we have created a frame work for cpu0 target machine (please
look back the llvm back end structure class inherit tree early in this
chapter).
Until now, we have 3027 lines of source code with comments which include files
*.cpp, *.h, *.td, CMakeLists.txt and LLVMBuild.txt.
It can be counted by command <tt class="docutils literal"><span class="pre">wc</span> <span class="pre">`find</span> <span class="pre">dir</span> <span class="pre">-name</span> <span class="pre">*.cpp`</span></tt> for files *.cpp,
*.h, *.td, *.txt.
LLVM front end tutorial have 700 lines of source code without comments totally.
Don&#8217;t feel down with this result.
In reality, write a back end is warm up slowly but run fast.
Clang has over 500,000 lines of source code with comments in clang/lib
directory which include C++ and Obj C support.
Mips back end has only 15,000 lines with comments.
Even the complicate X86 CPU which CISC outside and RISC inside (micro
instruction), has only 45,000 lines with comments.
In next chapter, we will show you that add a new instruction support is as easy
as 123.</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine">http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[5]</a></td><td><a class="reference external" href="http://www.opus.ub.uni-erlangen.de/opus/volltexte/2010/1659/pdf/tricore_llvm.pdf">http://www.opus.ub.uni-erlangen.de/opus/volltexte/2010/1659/pdf/tricore_llvm.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[6]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Instruction_selection">http://en.wikipedia.org/wiki/Instruction_selection</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">LLVM Backend Structure</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#step-0-build-example-code">Step 0. Build Example Code</a></li>
<li><a class="reference internal" href="#step-1-add-xxtargetmachine">Step 1. Add XXTargetMachine</a></li>
<li><a class="reference internal" href="#step-2-add-registerinfo">Step 2. Add RegisterInfo</a></li>
<li><a class="reference internal" href="#step-3-add-asmprinter">Step 3. Add AsmPrinter</a></li>
<li><a class="reference internal" href="#llvm-code-generation-sequence">LLVM Code Generation Sequence</a></li>
<li><a class="reference internal" href="#dag-directed-acyclic-graph">DAG (Directed Acyclic Graph)</a></li>
<li><a class="reference internal" href="#id8">Instruction Selection</a></li>
<li><a class="reference internal" href="#step-4-add-cpu0dagtodagisel">Step 4. Add Cpu0DAGToDAGISel</a></li>
<li><a class="reference internal" href="#step-5-add-prologue-epilogue">Step 5. Add Prologue/Epilogue</a></li>
<li><a class="reference internal" href="#summary-of-this-chapter">Summary of this Chapter</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="llvmstructure.html"
                        title="previous chapter">Cpu0 Instruction and LLVM Target Description</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="otherinst.html"
                        title="next chapter">Other instructions</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/backendstructure.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="otherinst.html" title="Other instructions"
             >next</a> |</li>
        <li class="right" >
          <a href="llvmstructure.html" title="Cpu0 Instruction and LLVM Target Description"
             >previous</a> |</li>
        <li><a href="index.html">Write An LLVM Backend Tutorial For Cpu0</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>